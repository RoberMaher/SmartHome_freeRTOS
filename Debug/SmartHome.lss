
SmartHome.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000229e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a0  00800060  0000229e  00002332  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045e  00800100  00800100  000023d2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023d2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002404  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000528  00000000  00000000  00002440  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005563  00000000  00000000  00002968  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013b1  00000000  00000000  00007ecb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000032f1  00000000  00000000  0000927c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ff8  00000000  00000000  0000c570  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001895  00000000  00000000  0000d568  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005218  00000000  00000000  0000edfd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f0  00000000  00000000  00014015  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 d6 0e 	jmp	0x1dac	; 0x1dac <__vector_1>
       8:	0c 94 fd 0e 	jmp	0x1dfa	; 0x1dfa <__vector_2>
       c:	0c 94 24 0f 	jmp	0x1e48	; 0x1e48 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 00 05 	jmp	0xa00	; 0xa00 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 72 0f 	jmp	0x1ee4	; 0x1ee4 <__vector_10>
      2c:	0c 94 4b 0f 	jmp	0x1e96	; 0x1e96 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e9       	ldi	r30, 0x9E	; 158
      68:	f2 e2       	ldi	r31, 0x22	; 34
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 30       	cpi	r26, 0x00	; 0
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 35       	cpi	r26, 0x5E	; 94
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <main>
      8a:	0c 94 4d 11 	jmp	0x229a	; 0x229a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <task1>:

SemaphoreHandle_t	semaphore;
QueueSetHandle_t	queue1;
QueueSetHandle_t	queue2;

void task1(void) {
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	1f 92       	push	r1
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
	u8 key;
			xSemaphoreTake(semaphore, 100);
      9c:	20 e0       	ldi	r18, 0x00	; 0
      9e:	44 e6       	ldi	r20, 0x64	; 100
      a0:	50 e0       	ldi	r21, 0x00	; 0
      a2:	60 e0       	ldi	r22, 0x00	; 0
      a4:	70 e0       	ldi	r23, 0x00	; 0
      a6:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
      aa:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
      ae:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
			key = UART_u8RX();
      b2:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <UART_u8RX>
      b6:	89 83       	std	Y+1, r24	; 0x01
			xQueueSend(queue1, &key, 100);
      b8:	20 e0       	ldi	r18, 0x00	; 0
      ba:	44 e6       	ldi	r20, 0x64	; 100
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	be 01       	movw	r22, r28
      c0:	6f 5f       	subi	r22, 0xFF	; 255
      c2:	7f 4f       	sbci	r23, 0xFF	; 255
      c4:	80 91 5c 05 	lds	r24, 0x055C	; 0x80055c <queue1>
      c8:	90 91 5d 05 	lds	r25, 0x055D	; 0x80055d <queue1+0x1>
      cc:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericSend>
			xSemaphoreGive(semaphore);
      d0:	20 e0       	ldi	r18, 0x00	; 0
      d2:	40 e0       	ldi	r20, 0x00	; 0
      d4:	50 e0       	ldi	r21, 0x00	; 0
      d6:	60 e0       	ldi	r22, 0x00	; 0
      d8:	70 e0       	ldi	r23, 0x00	; 0
      da:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
      de:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
      e2:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericSend>
		
		vTaskDelay(1000);
      e6:	88 ee       	ldi	r24, 0xE8	; 232
      e8:	93 e0       	ldi	r25, 0x03	; 3
      ea:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskDelay>
}
      ee:	0f 90       	pop	r0
      f0:	df 91       	pop	r29
      f2:	cf 91       	pop	r28
      f4:	08 95       	ret

000000f6 <task2>:

void task2(void) {
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
      fa:	1f 92       	push	r1
      fc:	cd b7       	in	r28, 0x3d	; 61
      fe:	de b7       	in	r29, 0x3e	; 62
u8 key;
xSemaphoreTake(semaphore,200);
     100:	20 e0       	ldi	r18, 0x00	; 0
     102:	48 ec       	ldi	r20, 0xC8	; 200
     104:	50 e0       	ldi	r21, 0x00	; 0
     106:	60 e0       	ldi	r22, 0x00	; 0
     108:	70 e0       	ldi	r23, 0x00	; 0
     10a:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
     10e:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
     112:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
xQueueReceive(queue1,&key,100);
     116:	20 e0       	ldi	r18, 0x00	; 0
     118:	44 e6       	ldi	r20, 0x64	; 100
     11a:	50 e0       	ldi	r21, 0x00	; 0
     11c:	be 01       	movw	r22, r28
     11e:	6f 5f       	subi	r22, 0xFF	; 255
     120:	7f 4f       	sbci	r23, 0xFF	; 255
     122:	80 91 5c 05 	lds	r24, 0x055C	; 0x80055c <queue1>
     126:	90 91 5d 05 	lds	r25, 0x055D	; 0x80055d <queue1+0x1>
     12a:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
switch (key){
     12e:	89 81       	ldd	r24, Y+1	; 0x01
     130:	82 37       	cpi	r24, 0x72	; 114
     132:	f1 f4       	brne	.+60     	; 0x170 <task2+0x7a>
	case 'r' :
	LCD_voidSendString("Correct Password");
     134:	82 e6       	ldi	r24, 0x62	; 98
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
	DIO_voidSetPinVal(DIO_PORTC,DIO_PIN0,HIGH);
     13c:	41 e0       	ldi	r20, 0x01	; 1
     13e:	60 e0       	ldi	r22, 0x00	; 0
     140:	82 e0       	ldi	r24, 0x02	; 2
     142:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     146:	2f ef       	ldi	r18, 0xFF	; 255
     148:	33 ed       	ldi	r19, 0xD3	; 211
     14a:	80 e3       	ldi	r24, 0x30	; 48
     14c:	21 50       	subi	r18, 0x01	; 1
     14e:	30 40       	sbci	r19, 0x00	; 0
     150:	80 40       	sbci	r24, 0x00	; 0
     152:	e1 f7       	brne	.-8      	; 0x14c <task2+0x56>
     154:	00 c0       	rjmp	.+0      	; 0x156 <task2+0x60>
     156:	00 00       	nop
	_delay_ms(1000);
	xSemaphoreGive(semaphore);
     158:	20 e0       	ldi	r18, 0x00	; 0
     15a:	40 e0       	ldi	r20, 0x00	; 0
     15c:	50 e0       	ldi	r21, 0x00	; 0
     15e:	60 e0       	ldi	r22, 0x00	; 0
     160:	70 e0       	ldi	r23, 0x00	; 0
     162:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
     166:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
     16a:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericSend>
	break;
     16e:	20 c0       	rjmp	.+64     	; 0x1b0 <task2+0xba>
	
	default:
	LCD_voidGotoxy(0,0);
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	80 e0       	ldi	r24, 0x00	; 0
     174:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
	LCD_voidSendString("Wrong Password");
     178:	83 e7       	ldi	r24, 0x73	; 115
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
	LCD_voidGotoxy(0,1);
     180:	61 e0       	ldi	r22, 0x01	; 1
     182:	80 e0       	ldi	r24, 0x00	; 0
     184:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
	LCD_voidSendString("System is Closed");
     188:	82 e8       	ldi	r24, 0x82	; 130
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
	DIO_voidSetPinVal(DIO_PORTC,DIO_PIN1,HIGH);
     190:	41 e0       	ldi	r20, 0x01	; 1
     192:	61 e0       	ldi	r22, 0x01	; 1
     194:	82 e0       	ldi	r24, 0x02	; 2
     196:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
     19a:	9f ef       	ldi	r25, 0xFF	; 255
     19c:	23 eb       	ldi	r18, 0xB3	; 179
     19e:	34 ec       	ldi	r19, 0xC4	; 196
     1a0:	84 e0       	ldi	r24, 0x04	; 4
     1a2:	91 50       	subi	r25, 0x01	; 1
     1a4:	20 40       	sbci	r18, 0x00	; 0
     1a6:	30 40       	sbci	r19, 0x00	; 0
     1a8:	80 40       	sbci	r24, 0x00	; 0
     1aa:	d9 f7       	brne	.-10     	; 0x1a2 <task2+0xac>
     1ac:	00 c0       	rjmp	.+0      	; 0x1ae <task2+0xb8>
     1ae:	00 00       	nop
	_delay_ms(30000);

}
vTaskDelay(2000);
     1b0:	80 ed       	ldi	r24, 0xD0	; 208
     1b2:	97 e0       	ldi	r25, 0x07	; 7
     1b4:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskDelay>
}
     1b8:	0f 90       	pop	r0
     1ba:	df 91       	pop	r29
     1bc:	cf 91       	pop	r28
     1be:	08 95       	ret

000001c0 <task3>:

void task3(void) {
     1c0:	cf 93       	push	r28
     1c2:	df 93       	push	r29
     1c4:	00 d0       	rcall	.+0      	; 0x1c6 <task3+0x6>
     1c6:	00 d0       	rcall	.+0      	; 0x1c8 <task3+0x8>
     1c8:	cd b7       	in	r28, 0x3d	; 61
     1ca:	de b7       	in	r29, 0x3e	; 62
	u16 val = 0;
	f32 temp = 0;
     1cc:	19 82       	std	Y+1, r1	; 0x01
     1ce:	1a 82       	std	Y+2, r1	; 0x02
     1d0:	1b 82       	std	Y+3, r1	; 0x03
     1d2:	1c 82       	std	Y+4, r1	; 0x04
	if (xSemaphoreTake(semaphore, 300) == pdTRUE) {
     1d4:	20 e0       	ldi	r18, 0x00	; 0
     1d6:	4c e2       	ldi	r20, 0x2C	; 44
     1d8:	51 e0       	ldi	r21, 0x01	; 1
     1da:	60 e0       	ldi	r22, 0x00	; 0
     1dc:	70 e0       	ldi	r23, 0x00	; 0
     1de:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
     1e2:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
     1e6:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
     1ea:	81 30       	cpi	r24, 0x01	; 1
     1ec:	29 f5       	brne	.+74     	; 0x238 <task3+0x78>
	while (1) {

			val = ADC_u16ReadChannel(ADC_0);
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <ADC_u16ReadChannel>
			temp = (f32)val * 500 / 1024;
     1f4:	bc 01       	movw	r22, r24
     1f6:	80 e0       	ldi	r24, 0x00	; 0
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <__floatunsisf>
     1fe:	20 e0       	ldi	r18, 0x00	; 0
     200:	30 e0       	ldi	r19, 0x00	; 0
     202:	4a ef       	ldi	r20, 0xFA	; 250
     204:	53 e4       	ldi	r21, 0x43	; 67
     206:	0e 94 8d 10 	call	0x211a	; 0x211a <__mulsf3>
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	30 e0       	ldi	r19, 0x00	; 0
     20e:	40 e8       	ldi	r20, 0x80	; 128
     210:	5a e3       	ldi	r21, 0x3A	; 58
     212:	0e 94 8d 10 	call	0x211a	; 0x211a <__mulsf3>
     216:	69 83       	std	Y+1, r22	; 0x01
     218:	7a 83       	std	Y+2, r23	; 0x02
     21a:	8b 83       	std	Y+3, r24	; 0x03
     21c:	9c 83       	std	Y+4, r25	; 0x04
			xQueueSend(queue2, &temp, 200);
     21e:	20 e0       	ldi	r18, 0x00	; 0
     220:	48 ec       	ldi	r20, 0xC8	; 200
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	80 91 5a 05 	lds	r24, 0x055A	; 0x80055a <queue2>
     22e:	90 91 5b 05 	lds	r25, 0x055B	; 0x80055b <queue2+0x1>
     232:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericSend>
     236:	db cf       	rjmp	.-74     	; 0x1ee <task3+0x2e>
			
		}
	}
		xSemaphoreGive(semaphore);
     238:	20 e0       	ldi	r18, 0x00	; 0
     23a:	40 e0       	ldi	r20, 0x00	; 0
     23c:	50 e0       	ldi	r21, 0x00	; 0
     23e:	60 e0       	ldi	r22, 0x00	; 0
     240:	70 e0       	ldi	r23, 0x00	; 0
     242:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
     246:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
     24a:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericSend>
		vTaskDelay(3000);
     24e:	88 eb       	ldi	r24, 0xB8	; 184
     250:	9b e0       	ldi	r25, 0x0B	; 11
     252:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskDelay>
}
     256:	0f 90       	pop	r0
     258:	0f 90       	pop	r0
     25a:	0f 90       	pop	r0
     25c:	0f 90       	pop	r0
     25e:	df 91       	pop	r29
     260:	cf 91       	pop	r28
     262:	08 95       	ret

00000264 <task4>:

void task4(void) {
     264:	cf 92       	push	r12
     266:	df 92       	push	r13
     268:	ef 92       	push	r14
     26a:	ff 92       	push	r15
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	00 d0       	rcall	.+0      	; 0x272 <task4+0xe>
     272:	00 d0       	rcall	.+0      	; 0x274 <task4+0x10>
     274:	cd b7       	in	r28, 0x3d	; 61
     276:	de b7       	in	r29, 0x3e	; 62
	f32 temp;
	u8 dc = 0;
		if (xSemaphoreTake(semaphore, 400) == pdTRUE) {
     278:	20 e0       	ldi	r18, 0x00	; 0
     27a:	40 e9       	ldi	r20, 0x90	; 144
     27c:	51 e0       	ldi	r21, 0x01	; 1
     27e:	60 e0       	ldi	r22, 0x00	; 0
     280:	70 e0       	ldi	r23, 0x00	; 0
     282:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <semaphore>
     286:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <semaphore+0x1>
     28a:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
     28e:	81 30       	cpi	r24, 0x01	; 1
     290:	09 f0       	breq	.+2      	; 0x294 <task4+0x30>
     292:	90 c0       	rjmp	.+288    	; 0x3b4 <task4+0x150>
	while (1) {
		xQueueReceive(queue2, &temp, 200); 
     294:	20 e0       	ldi	r18, 0x00	; 0
     296:	48 ec       	ldi	r20, 0xC8	; 200
     298:	50 e0       	ldi	r21, 0x00	; 0
     29a:	be 01       	movw	r22, r28
     29c:	6f 5f       	subi	r22, 0xFF	; 255
     29e:	7f 4f       	sbci	r23, 0xFF	; 255
     2a0:	80 91 5a 05 	lds	r24, 0x055A	; 0x80055a <queue2>
     2a4:	90 91 5b 05 	lds	r25, 0x055B	; 0x80055b <queue2+0x1>
     2a8:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <xQueueGenericReceive>
			LCD_voidSendCommand(1);
     2ac:	81 e0       	ldi	r24, 0x01	; 1
     2ae:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_voidSendCommand>
			LCD_voidGotoxy(0, 0);
     2b2:	60 e0       	ldi	r22, 0x00	; 0
     2b4:	80 e0       	ldi	r24, 0x00	; 0
     2b6:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
			LCD_voidSendString("Temperature = ");
     2ba:	83 e9       	ldi	r24, 0x93	; 147
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
			LCD_voidSendNumber(temp);
     2c2:	69 81       	ldd	r22, Y+1	; 0x01
     2c4:	7a 81       	ldd	r23, Y+2	; 0x02
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <__fixunssfsi>
     2ce:	0e 94 75 0d 	call	0x1aea	; 0x1aea <LCD_voidSendNumber>

			if (temp < 20) {
     2d2:	c9 80       	ldd	r12, Y+1	; 0x01
     2d4:	da 80       	ldd	r13, Y+2	; 0x02
     2d6:	eb 80       	ldd	r14, Y+3	; 0x03
     2d8:	fc 80       	ldd	r15, Y+4	; 0x04
     2da:	20 e0       	ldi	r18, 0x00	; 0
     2dc:	30 e0       	ldi	r19, 0x00	; 0
     2de:	40 ea       	ldi	r20, 0xA0	; 160
     2e0:	51 e4       	ldi	r21, 0x41	; 65
     2e2:	c7 01       	movw	r24, r14
     2e4:	b6 01       	movw	r22, r12
     2e6:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <__cmpsf2>
     2ea:	88 23       	and	r24, r24
     2ec:	64 f4       	brge	.+24     	; 0x306 <task4+0xa2>
				dc = 0;
				TIMER0_voidFastPWM(dc);
     2ee:	80 e0       	ldi	r24, 0x00	; 0
     2f0:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0, 1);
     2f4:	61 e0       	ldi	r22, 0x01	; 1
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 0%");
     2fc:	82 ea       	ldi	r24, 0xA2	; 162
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
     304:	c7 cf       	rjmp	.-114    	; 0x294 <task4+0x30>
				}
				else if (temp >=20 && temp < 40) {
     306:	20 e0       	ldi	r18, 0x00	; 0
     308:	30 e0       	ldi	r19, 0x00	; 0
     30a:	40 ea       	ldi	r20, 0xA0	; 160
     30c:	51 e4       	ldi	r21, 0x41	; 65
     30e:	c7 01       	movw	r24, r14
     310:	b6 01       	movw	r22, r12
     312:	0e 94 88 10 	call	0x2110	; 0x2110 <__gesf2>
     316:	88 23       	and	r24, r24
     318:	b4 f0       	brlt	.+44     	; 0x346 <task4+0xe2>
     31a:	20 e0       	ldi	r18, 0x00	; 0
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	40 e2       	ldi	r20, 0x20	; 32
     320:	52 e4       	ldi	r21, 0x42	; 66
     322:	c7 01       	movw	r24, r14
     324:	b6 01       	movw	r22, r12
     326:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <__cmpsf2>
     32a:	88 23       	and	r24, r24
     32c:	64 f4       	brge	.+24     	; 0x346 <task4+0xe2>
				dc = 30;
				TIMER0_voidFastPWM(dc);
     32e:	8e e1       	ldi	r24, 0x1E	; 30
     330:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0, 1);
     334:	61 e0       	ldi	r22, 0x01	; 1
     336:	80 e0       	ldi	r24, 0x00	; 0
     338:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 30%");
     33c:	81 eb       	ldi	r24, 0xB1	; 177
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
     344:	a7 cf       	rjmp	.-178    	; 0x294 <task4+0x30>
				}
				else if (temp >=40 && temp < 50) {
     346:	20 e0       	ldi	r18, 0x00	; 0
     348:	30 e0       	ldi	r19, 0x00	; 0
     34a:	40 e2       	ldi	r20, 0x20	; 32
     34c:	52 e4       	ldi	r21, 0x42	; 66
     34e:	c7 01       	movw	r24, r14
     350:	b6 01       	movw	r22, r12
     352:	0e 94 88 10 	call	0x2110	; 0x2110 <__gesf2>
     356:	88 23       	and	r24, r24
     358:	b4 f0       	brlt	.+44     	; 0x386 <task4+0x122>
     35a:	20 e0       	ldi	r18, 0x00	; 0
     35c:	30 e0       	ldi	r19, 0x00	; 0
     35e:	48 e4       	ldi	r20, 0x48	; 72
     360:	52 e4       	ldi	r21, 0x42	; 66
     362:	c7 01       	movw	r24, r14
     364:	b6 01       	movw	r22, r12
     366:	0e 94 ca 0f 	call	0x1f94	; 0x1f94 <__cmpsf2>
     36a:	88 23       	and	r24, r24
     36c:	64 f4       	brge	.+24     	; 0x386 <task4+0x122>
				dc = 50;
				TIMER0_voidFastPWM(dc);
     36e:	82 e3       	ldi	r24, 0x32	; 50
     370:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0, 1);
     374:	61 e0       	ldi	r22, 0x01	; 1
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 50%");
     37c:	81 ec       	ldi	r24, 0xC1	; 193
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
     384:	87 cf       	rjmp	.-242    	; 0x294 <task4+0x30>
				} 
				else if(temp >= 50) {
     386:	20 e0       	ldi	r18, 0x00	; 0
     388:	30 e0       	ldi	r19, 0x00	; 0
     38a:	48 e4       	ldi	r20, 0x48	; 72
     38c:	52 e4       	ldi	r21, 0x42	; 66
     38e:	c7 01       	movw	r24, r14
     390:	b6 01       	movw	r22, r12
     392:	0e 94 88 10 	call	0x2110	; 0x2110 <__gesf2>
     396:	88 23       	and	r24, r24
     398:	0c f4       	brge	.+2      	; 0x39c <task4+0x138>
     39a:	7c cf       	rjmp	.-264    	; 0x294 <task4+0x30>
				dc = 99;
				TIMER0_voidFastPWM(dc);
     39c:	83 e6       	ldi	r24, 0x63	; 99
     39e:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0, 1);
     3a2:	61 e0       	ldi	r22, 0x01	; 1
     3a4:	80 e0       	ldi	r24, 0x00	; 0
     3a6:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 100%");
     3aa:	81 ed       	ldi	r24, 0xD1	; 209
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <LCD_voidSendString>
     3b2:	70 cf       	rjmp	.-288    	; 0x294 <task4+0x30>
			}
		}
	}
	vTaskDelay(4000);
     3b4:	80 ea       	ldi	r24, 0xA0	; 160
     3b6:	9f e0       	ldi	r25, 0x0F	; 15
     3b8:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskDelay>
}
     3bc:	0f 90       	pop	r0
     3be:	0f 90       	pop	r0
     3c0:	0f 90       	pop	r0
     3c2:	0f 90       	pop	r0
     3c4:	df 91       	pop	r29
     3c6:	cf 91       	pop	r28
     3c8:	ff 90       	pop	r15
     3ca:	ef 90       	pop	r14
     3cc:	df 90       	pop	r13
     3ce:	cf 90       	pop	r12
     3d0:	08 95       	ret

000003d2 <main>:

void main(void) {
     3d2:	ef 92       	push	r14
     3d4:	ff 92       	push	r15
     3d6:	0f 93       	push	r16
	DIO_voidSetPortDir(DIO_PORTA, 0xf0);
     3d8:	60 ef       	ldi	r22, 0xF0	; 240
     3da:	80 e0       	ldi	r24, 0x00	; 0
     3dc:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <DIO_voidSetPortDir>
	DIO_voidSetPortDir(DIO_PORTB, 0xcf);
     3e0:	6f ec       	ldi	r22, 0xCF	; 207
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	0e 94 c6 0e 	call	0x1d8c	; 0x1d8c <DIO_voidSetPortDir>
	DIO_voidSetPinDir(DIO_PORTC, DIO_PIN0, OUTPUT);
     3e8:	41 e0       	ldi	r20, 0x01	; 1
     3ea:	60 e0       	ldi	r22, 0x00	; 0
     3ec:	82 e0       	ldi	r24, 0x02	; 2
     3ee:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTC, DIO_PIN1, OUTPUT);
     3f2:	41 e0       	ldi	r20, 0x01	; 1
     3f4:	61 e0       	ldi	r22, 0x01	; 1
     3f6:	82 e0       	ldi	r24, 0x02	; 2
     3f8:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <DIO_voidSetPinDir>

	LCD_voidInit();
     3fc:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <LCD_voidInit>
	ADC_voidInit();
     400:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <ADC_voidInit>
	UART_voidInit();
     404:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <UART_voidInit>

	xTaskCreate(task1, "task1", 80, NULL, 4, NULL);
     408:	e1 2c       	mov	r14, r1
     40a:	f1 2c       	mov	r15, r1
     40c:	04 e0       	ldi	r16, 0x04	; 4
     40e:	20 e0       	ldi	r18, 0x00	; 0
     410:	30 e0       	ldi	r19, 0x00	; 0
     412:	40 e5       	ldi	r20, 0x50	; 80
     414:	50 e0       	ldi	r21, 0x00	; 0
     416:	62 ee       	ldi	r22, 0xE2	; 226
     418:	70 e0       	ldi	r23, 0x00	; 0
     41a:	89 e4       	ldi	r24, 0x49	; 73
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	0e 94 23 09 	call	0x1246	; 0x1246 <xTaskCreate>
	xTaskCreate(task2, "task2", 80, NULL, 3, NULL);
     422:	03 e0       	ldi	r16, 0x03	; 3
     424:	20 e0       	ldi	r18, 0x00	; 0
     426:	30 e0       	ldi	r19, 0x00	; 0
     428:	40 e5       	ldi	r20, 0x50	; 80
     42a:	50 e0       	ldi	r21, 0x00	; 0
     42c:	68 ee       	ldi	r22, 0xE8	; 232
     42e:	70 e0       	ldi	r23, 0x00	; 0
     430:	8b e7       	ldi	r24, 0x7B	; 123
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 23 09 	call	0x1246	; 0x1246 <xTaskCreate>
	xTaskCreate(task3, "task3", 80, NULL, 2, NULL);
     438:	02 e0       	ldi	r16, 0x02	; 2
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	40 e5       	ldi	r20, 0x50	; 80
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	6e ee       	ldi	r22, 0xEE	; 238
     444:	70 e0       	ldi	r23, 0x00	; 0
     446:	80 ee       	ldi	r24, 0xE0	; 224
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	0e 94 23 09 	call	0x1246	; 0x1246 <xTaskCreate>
	xTaskCreate(task4, "task4", 80, NULL, 1, NULL);
     44e:	01 e0       	ldi	r16, 0x01	; 1
     450:	20 e0       	ldi	r18, 0x00	; 0
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	40 e5       	ldi	r20, 0x50	; 80
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	64 ef       	ldi	r22, 0xF4	; 244
     45a:	70 e0       	ldi	r23, 0x00	; 0
     45c:	82 e3       	ldi	r24, 0x32	; 50
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	0e 94 23 09 	call	0x1246	; 0x1246 <xTaskCreate>

	semaphore = xSemaphoreCreateBinary();
     464:	43 e0       	ldi	r20, 0x03	; 3
     466:	60 e0       	ldi	r22, 0x00	; 0
     468:	81 e0       	ldi	r24, 0x01	; 1
     46a:	0e 94 24 06 	call	0xc48	; 0xc48 <xQueueGenericCreate>
     46e:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <semaphore+0x1>
     472:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <semaphore>

	queue1 = xQueueCreate(1, sizeof(u8));
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	61 e0       	ldi	r22, 0x01	; 1
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	0e 94 24 06 	call	0xc48	; 0xc48 <xQueueGenericCreate>
     480:	90 93 5d 05 	sts	0x055D, r25	; 0x80055d <queue1+0x1>
     484:	80 93 5c 05 	sts	0x055C, r24	; 0x80055c <queue1>
	queue2 = xQueueCreate(1, sizeof(f32));
     488:	40 e0       	ldi	r20, 0x00	; 0
     48a:	64 e0       	ldi	r22, 0x04	; 4
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	0e 94 24 06 	call	0xc48	; 0xc48 <xQueueGenericCreate>
     492:	90 93 5b 05 	sts	0x055B, r25	; 0x80055b <queue2+0x1>
     496:	80 93 5a 05 	sts	0x055A, r24	; 0x80055a <queue2>

	vTaskStartScheduler();
     49a:	0e 94 77 09 	call	0x12ee	; 0x12ee <vTaskStartScheduler>
}
     49e:	0f 91       	pop	r16
     4a0:	ff 90       	pop	r15
     4a2:	ef 90       	pop	r14
     4a4:	08 95       	ret

000004a6 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     4a6:	e5 e0       	ldi	r30, 0x05	; 5
     4a8:	f1 e0       	ldi	r31, 0x01	; 1
     4aa:	8a e0       	ldi	r24, 0x0A	; 10
     4ac:	91 e0       	ldi	r25, 0x01	; 1
     4ae:	91 83       	std	Z+1, r25	; 0x01
     4b0:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     4b2:	13 82       	std	Z+3, r1	; 0x03
     4b4:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     4b6:	e1 e0       	ldi	r30, 0x01	; 1
     4b8:	f1 e0       	ldi	r31, 0x01	; 1
     4ba:	87 ee       	ldi	r24, 0xE7	; 231
     4bc:	93 e0       	ldi	r25, 0x03	; 3
     4be:	93 83       	std	Z+3, r25	; 0x03
     4c0:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     4c2:	11 82       	std	Z+1, r1	; 0x01
     4c4:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     4c6:	a9 e0       	ldi	r26, 0x09	; 9
     4c8:	b1 e0       	ldi	r27, 0x01	; 1
     4ca:	14 96       	adiw	r26, 0x04	; 4
     4cc:	9c 93       	st	X, r25
     4ce:	8e 93       	st	-X, r24
     4d0:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     4d2:	12 96       	adiw	r26, 0x02	; 2
     4d4:	fc 93       	st	X, r31
     4d6:	ee 93       	st	-X, r30
     4d8:	11 97       	sbiw	r26, 0x01	; 1
     4da:	08 95       	ret

000004dc <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     4e6:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     4ea:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_end>
     4ee:	81 11       	cpse	r24, r1
     4f0:	05 c0       	rjmp	.+10     	; 0x4fc <pvPortMalloc+0x20>
		{
			prvHeapInit();
     4f2:	0e 94 53 02 	call	0x4a6	; 0x4a6 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     4f6:	81 e0       	ldi	r24, 0x01	; 1
     4f8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     4fc:	20 97       	sbiw	r28, 0x00	; 0
     4fe:	09 f0       	breq	.+2      	; 0x502 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     500:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     502:	ce 01       	movw	r24, r28
     504:	01 97       	sbiw	r24, 0x01	; 1
     506:	86 3e       	cpi	r24, 0xE6	; 230
     508:	93 40       	sbci	r25, 0x03	; 3
     50a:	08 f0       	brcs	.+2      	; 0x50e <pvPortMalloc+0x32>
     50c:	56 c0       	rjmp	.+172    	; 0x5ba <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     50e:	e0 91 05 01 	lds	r30, 0x0105	; 0x800105 <xStart>
     512:	f0 91 06 01 	lds	r31, 0x0106	; 0x800106 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     516:	a5 e0       	ldi	r26, 0x05	; 5
     518:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     51a:	02 c0       	rjmp	.+4      	; 0x520 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     51c:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     51e:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     520:	82 81       	ldd	r24, Z+2	; 0x02
     522:	93 81       	ldd	r25, Z+3	; 0x03
     524:	8c 17       	cp	r24, r28
     526:	9d 07       	cpc	r25, r29
     528:	20 f4       	brcc	.+8      	; 0x532 <pvPortMalloc+0x56>
     52a:	80 81       	ld	r24, Z
     52c:	91 81       	ldd	r25, Z+1	; 0x01
     52e:	00 97       	sbiw	r24, 0x00	; 0
     530:	a9 f7       	brne	.-22     	; 0x51c <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	e1 30       	cpi	r30, 0x01	; 1
     536:	f8 07       	cpc	r31, r24
     538:	09 f4       	brne	.+2      	; 0x53c <pvPortMalloc+0x60>
     53a:	42 c0       	rjmp	.+132    	; 0x5c0 <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     53c:	0d 91       	ld	r16, X+
     53e:	1c 91       	ld	r17, X
     540:	11 97       	sbiw	r26, 0x01	; 1
     542:	0c 5f       	subi	r16, 0xFC	; 252
     544:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     546:	80 81       	ld	r24, Z
     548:	91 81       	ldd	r25, Z+1	; 0x01
     54a:	8d 93       	st	X+, r24
     54c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     54e:	82 81       	ldd	r24, Z+2	; 0x02
     550:	93 81       	ldd	r25, Z+3	; 0x03
     552:	8c 1b       	sub	r24, r28
     554:	9d 0b       	sbc	r25, r29
     556:	89 30       	cpi	r24, 0x09	; 9
     558:	91 05       	cpc	r25, r1
     55a:	10 f1       	brcs	.+68     	; 0x5a0 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     55c:	af 01       	movw	r20, r30
     55e:	4c 0f       	add	r20, r28
     560:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     562:	da 01       	movw	r26, r20
     564:	13 96       	adiw	r26, 0x03	; 3
     566:	9c 93       	st	X, r25
     568:	8e 93       	st	-X, r24
     56a:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     56c:	d3 83       	std	Z+3, r29	; 0x03
     56e:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     570:	12 96       	adiw	r26, 0x02	; 2
     572:	2d 91       	ld	r18, X+
     574:	3c 91       	ld	r19, X
     576:	13 97       	sbiw	r26, 0x03	; 3
     578:	65 e0       	ldi	r22, 0x05	; 5
     57a:	71 e0       	ldi	r23, 0x01	; 1
     57c:	01 c0       	rjmp	.+2      	; 0x580 <pvPortMalloc+0xa4>
     57e:	bd 01       	movw	r22, r26
     580:	eb 01       	movw	r28, r22
     582:	a8 81       	ld	r26, Y
     584:	b9 81       	ldd	r27, Y+1	; 0x01
     586:	12 96       	adiw	r26, 0x02	; 2
     588:	8d 91       	ld	r24, X+
     58a:	9c 91       	ld	r25, X
     58c:	13 97       	sbiw	r26, 0x03	; 3
     58e:	82 17       	cp	r24, r18
     590:	93 07       	cpc	r25, r19
     592:	a8 f3       	brcs	.-22     	; 0x57e <pvPortMalloc+0xa2>
     594:	ea 01       	movw	r28, r20
     596:	b9 83       	std	Y+1, r27	; 0x01
     598:	a8 83       	st	Y, r26
     59a:	db 01       	movw	r26, r22
     59c:	4d 93       	st	X+, r20
     59e:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     5a0:	22 81       	ldd	r18, Z+2	; 0x02
     5a2:	33 81       	ldd	r19, Z+3	; 0x03
     5a4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     5a8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     5ac:	82 1b       	sub	r24, r18
     5ae:	93 0b       	sbc	r25, r19
     5b0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     5b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     5b8:	05 c0       	rjmp	.+10     	; 0x5c4 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     5ba:	00 e0       	ldi	r16, 0x00	; 0
     5bc:	10 e0       	ldi	r17, 0x00	; 0
     5be:	02 c0       	rjmp	.+4      	; 0x5c4 <pvPortMalloc+0xe8>
     5c0:	00 e0       	ldi	r16, 0x00	; 0
     5c2:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5c4:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5c8:	c8 01       	movw	r24, r16
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	1f 91       	pop	r17
     5d0:	0f 91       	pop	r16
     5d2:	08 95       	ret

000005d4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5d4:	0f 93       	push	r16
     5d6:	1f 93       	push	r17
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     5dc:	00 97       	sbiw	r24, 0x00	; 0
     5de:	41 f1       	breq	.+80     	; 0x630 <vPortFree+0x5c>
     5e0:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     5e2:	8c 01       	movw	r16, r24
     5e4:	04 50       	subi	r16, 0x04	; 4
     5e6:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     5e8:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     5ec:	f8 01       	movw	r30, r16
     5ee:	42 81       	ldd	r20, Z+2	; 0x02
     5f0:	53 81       	ldd	r21, Z+3	; 0x03
     5f2:	a5 e0       	ldi	r26, 0x05	; 5
     5f4:	b1 e0       	ldi	r27, 0x01	; 1
     5f6:	01 c0       	rjmp	.+2      	; 0x5fa <vPortFree+0x26>
     5f8:	df 01       	movw	r26, r30
     5fa:	ed 91       	ld	r30, X+
     5fc:	fc 91       	ld	r31, X
     5fe:	11 97       	sbiw	r26, 0x01	; 1
     600:	22 81       	ldd	r18, Z+2	; 0x02
     602:	33 81       	ldd	r19, Z+3	; 0x03
     604:	24 17       	cp	r18, r20
     606:	35 07       	cpc	r19, r21
     608:	b8 f3       	brcs	.-18     	; 0x5f8 <vPortFree+0x24>
     60a:	24 97       	sbiw	r28, 0x04	; 4
     60c:	f9 83       	std	Y+1, r31	; 0x01
     60e:	e8 83       	st	Y, r30
     610:	0d 93       	st	X+, r16
     612:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     614:	8a 81       	ldd	r24, Y+2	; 0x02
     616:	9b 81       	ldd	r25, Y+3	; 0x03
     618:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     61c:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     620:	82 0f       	add	r24, r18
     622:	93 1f       	adc	r25, r19
     624:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     628:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     62c:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
	}
}
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	1f 91       	pop	r17
     636:	0f 91       	pop	r16
     638:	08 95       	ret

0000063a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     63a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     63c:	03 96       	adiw	r24, 0x03	; 3
     63e:	92 83       	std	Z+2, r25	; 0x02
     640:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     642:	2f ef       	ldi	r18, 0xFF	; 255
     644:	3f ef       	ldi	r19, 0xFF	; 255
     646:	34 83       	std	Z+4, r19	; 0x04
     648:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     64a:	96 83       	std	Z+6, r25	; 0x06
     64c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     64e:	90 87       	std	Z+8, r25	; 0x08
     650:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     652:	10 82       	st	Z, r1
     654:	08 95       	ret

00000656 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     656:	fc 01       	movw	r30, r24
     658:	11 86       	std	Z+9, r1	; 0x09
     65a:	10 86       	std	Z+8, r1	; 0x08
     65c:	08 95       	ret

0000065e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	9c 01       	movw	r18, r24
     664:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     666:	dc 01       	movw	r26, r24
     668:	11 96       	adiw	r26, 0x01	; 1
     66a:	cd 91       	ld	r28, X+
     66c:	dc 91       	ld	r29, X
     66e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     670:	d3 83       	std	Z+3, r29	; 0x03
     672:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     674:	8c 81       	ldd	r24, Y+4	; 0x04
     676:	9d 81       	ldd	r25, Y+5	; 0x05
     678:	95 83       	std	Z+5, r25	; 0x05
     67a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     67c:	8c 81       	ldd	r24, Y+4	; 0x04
     67e:	9d 81       	ldd	r25, Y+5	; 0x05
     680:	dc 01       	movw	r26, r24
     682:	13 96       	adiw	r26, 0x03	; 3
     684:	7c 93       	st	X, r23
     686:	6e 93       	st	-X, r22
     688:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     68a:	7d 83       	std	Y+5, r23	; 0x05
     68c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68e:	31 87       	std	Z+9, r19	; 0x09
     690:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     692:	f9 01       	movw	r30, r18
     694:	80 81       	ld	r24, Z
     696:	8f 5f       	subi	r24, 0xFF	; 255
     698:	80 83       	st	Z, r24
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	08 95       	ret

000006a0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6a0:	cf 93       	push	r28
     6a2:	df 93       	push	r29
     6a4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6a6:	48 81       	ld	r20, Y
     6a8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6aa:	4f 3f       	cpi	r20, 0xFF	; 255
     6ac:	2f ef       	ldi	r18, 0xFF	; 255
     6ae:	52 07       	cpc	r21, r18
     6b0:	21 f4       	brne	.+8      	; 0x6ba <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6b2:	fc 01       	movw	r30, r24
     6b4:	a7 81       	ldd	r26, Z+7	; 0x07
     6b6:	b0 85       	ldd	r27, Z+8	; 0x08
     6b8:	0d c0       	rjmp	.+26     	; 0x6d4 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ba:	dc 01       	movw	r26, r24
     6bc:	13 96       	adiw	r26, 0x03	; 3
     6be:	01 c0       	rjmp	.+2      	; 0x6c2 <vListInsert+0x22>
     6c0:	df 01       	movw	r26, r30
     6c2:	12 96       	adiw	r26, 0x02	; 2
     6c4:	ed 91       	ld	r30, X+
     6c6:	fc 91       	ld	r31, X
     6c8:	13 97       	sbiw	r26, 0x03	; 3
     6ca:	20 81       	ld	r18, Z
     6cc:	31 81       	ldd	r19, Z+1	; 0x01
     6ce:	42 17       	cp	r20, r18
     6d0:	53 07       	cpc	r21, r19
     6d2:	b0 f7       	brcc	.-20     	; 0x6c0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6d4:	12 96       	adiw	r26, 0x02	; 2
     6d6:	ed 91       	ld	r30, X+
     6d8:	fc 91       	ld	r31, X
     6da:	13 97       	sbiw	r26, 0x03	; 3
     6dc:	fb 83       	std	Y+3, r31	; 0x03
     6de:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     6e0:	d5 83       	std	Z+5, r29	; 0x05
     6e2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     6e4:	bd 83       	std	Y+5, r27	; 0x05
     6e6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     6e8:	13 96       	adiw	r26, 0x03	; 3
     6ea:	dc 93       	st	X, r29
     6ec:	ce 93       	st	-X, r28
     6ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6f0:	99 87       	std	Y+9, r25	; 0x09
     6f2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6f4:	fc 01       	movw	r30, r24
     6f6:	20 81       	ld	r18, Z
     6f8:	2f 5f       	subi	r18, 0xFF	; 255
     6fa:	20 83       	st	Z, r18
}
     6fc:	df 91       	pop	r29
     6fe:	cf 91       	pop	r28
     700:	08 95       	ret

00000702 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     702:	cf 93       	push	r28
     704:	df 93       	push	r29
     706:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     708:	a0 85       	ldd	r26, Z+8	; 0x08
     70a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     70c:	c2 81       	ldd	r28, Z+2	; 0x02
     70e:	d3 81       	ldd	r29, Z+3	; 0x03
     710:	84 81       	ldd	r24, Z+4	; 0x04
     712:	95 81       	ldd	r25, Z+5	; 0x05
     714:	9d 83       	std	Y+5, r25	; 0x05
     716:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     718:	c4 81       	ldd	r28, Z+4	; 0x04
     71a:	d5 81       	ldd	r29, Z+5	; 0x05
     71c:	82 81       	ldd	r24, Z+2	; 0x02
     71e:	93 81       	ldd	r25, Z+3	; 0x03
     720:	9b 83       	std	Y+3, r25	; 0x03
     722:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     724:	11 96       	adiw	r26, 0x01	; 1
     726:	8d 91       	ld	r24, X+
     728:	9c 91       	ld	r25, X
     72a:	12 97       	sbiw	r26, 0x02	; 2
     72c:	e8 17       	cp	r30, r24
     72e:	f9 07       	cpc	r31, r25
     730:	31 f4       	brne	.+12     	; 0x73e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     732:	84 81       	ldd	r24, Z+4	; 0x04
     734:	95 81       	ldd	r25, Z+5	; 0x05
     736:	12 96       	adiw	r26, 0x02	; 2
     738:	9c 93       	st	X, r25
     73a:	8e 93       	st	-X, r24
     73c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     73e:	11 86       	std	Z+9, r1	; 0x09
     740:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     742:	8c 91       	ld	r24, X
     744:	81 50       	subi	r24, 0x01	; 1
     746:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     748:	df 91       	pop	r29
     74a:	cf 91       	pop	r28
     74c:	08 95       	ret

0000074e <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     74e:	1b bc       	out	0x2b, r1	; 43
     750:	89 ef       	ldi	r24, 0xF9	; 249
     752:	8a bd       	out	0x2a, r24	; 42
     754:	8b e0       	ldi	r24, 0x0B	; 11
     756:	8e bd       	out	0x2e, r24	; 46
     758:	89 b7       	in	r24, 0x39	; 57
     75a:	80 61       	ori	r24, 0x10	; 16
     75c:	89 bf       	out	0x39, r24	; 57
     75e:	08 95       	ret

00000760 <pxPortInitialiseStack>:
     760:	31 e1       	ldi	r19, 0x11	; 17
     762:	fc 01       	movw	r30, r24
     764:	30 83       	st	Z, r19
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	22 e2       	ldi	r18, 0x22	; 34
     76a:	20 83       	st	Z, r18
     76c:	31 97       	sbiw	r30, 0x01	; 1
     76e:	a3 e3       	ldi	r26, 0x33	; 51
     770:	a0 83       	st	Z, r26
     772:	31 97       	sbiw	r30, 0x01	; 1
     774:	60 83       	st	Z, r22
     776:	31 97       	sbiw	r30, 0x01	; 1
     778:	70 83       	st	Z, r23
     77a:	31 97       	sbiw	r30, 0x01	; 1
     77c:	10 82       	st	Z, r1
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	60 e8       	ldi	r22, 0x80	; 128
     782:	60 83       	st	Z, r22
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	10 82       	st	Z, r1
     788:	31 97       	sbiw	r30, 0x01	; 1
     78a:	62 e0       	ldi	r22, 0x02	; 2
     78c:	60 83       	st	Z, r22
     78e:	31 97       	sbiw	r30, 0x01	; 1
     790:	63 e0       	ldi	r22, 0x03	; 3
     792:	60 83       	st	Z, r22
     794:	31 97       	sbiw	r30, 0x01	; 1
     796:	64 e0       	ldi	r22, 0x04	; 4
     798:	60 83       	st	Z, r22
     79a:	31 97       	sbiw	r30, 0x01	; 1
     79c:	65 e0       	ldi	r22, 0x05	; 5
     79e:	60 83       	st	Z, r22
     7a0:	31 97       	sbiw	r30, 0x01	; 1
     7a2:	66 e0       	ldi	r22, 0x06	; 6
     7a4:	60 83       	st	Z, r22
     7a6:	31 97       	sbiw	r30, 0x01	; 1
     7a8:	67 e0       	ldi	r22, 0x07	; 7
     7aa:	60 83       	st	Z, r22
     7ac:	31 97       	sbiw	r30, 0x01	; 1
     7ae:	68 e0       	ldi	r22, 0x08	; 8
     7b0:	60 83       	st	Z, r22
     7b2:	31 97       	sbiw	r30, 0x01	; 1
     7b4:	69 e0       	ldi	r22, 0x09	; 9
     7b6:	60 83       	st	Z, r22
     7b8:	31 97       	sbiw	r30, 0x01	; 1
     7ba:	60 e1       	ldi	r22, 0x10	; 16
     7bc:	60 83       	st	Z, r22
     7be:	31 97       	sbiw	r30, 0x01	; 1
     7c0:	30 83       	st	Z, r19
     7c2:	31 97       	sbiw	r30, 0x01	; 1
     7c4:	32 e1       	ldi	r19, 0x12	; 18
     7c6:	30 83       	st	Z, r19
     7c8:	31 97       	sbiw	r30, 0x01	; 1
     7ca:	33 e1       	ldi	r19, 0x13	; 19
     7cc:	30 83       	st	Z, r19
     7ce:	31 97       	sbiw	r30, 0x01	; 1
     7d0:	34 e1       	ldi	r19, 0x14	; 20
     7d2:	30 83       	st	Z, r19
     7d4:	31 97       	sbiw	r30, 0x01	; 1
     7d6:	35 e1       	ldi	r19, 0x15	; 21
     7d8:	30 83       	st	Z, r19
     7da:	31 97       	sbiw	r30, 0x01	; 1
     7dc:	36 e1       	ldi	r19, 0x16	; 22
     7de:	30 83       	st	Z, r19
     7e0:	31 97       	sbiw	r30, 0x01	; 1
     7e2:	37 e1       	ldi	r19, 0x17	; 23
     7e4:	30 83       	st	Z, r19
     7e6:	31 97       	sbiw	r30, 0x01	; 1
     7e8:	38 e1       	ldi	r19, 0x18	; 24
     7ea:	30 83       	st	Z, r19
     7ec:	31 97       	sbiw	r30, 0x01	; 1
     7ee:	39 e1       	ldi	r19, 0x19	; 25
     7f0:	30 83       	st	Z, r19
     7f2:	31 97       	sbiw	r30, 0x01	; 1
     7f4:	30 e2       	ldi	r19, 0x20	; 32
     7f6:	30 83       	st	Z, r19
     7f8:	31 97       	sbiw	r30, 0x01	; 1
     7fa:	31 e2       	ldi	r19, 0x21	; 33
     7fc:	30 83       	st	Z, r19
     7fe:	31 97       	sbiw	r30, 0x01	; 1
     800:	20 83       	st	Z, r18
     802:	31 97       	sbiw	r30, 0x01	; 1
     804:	23 e2       	ldi	r18, 0x23	; 35
     806:	20 83       	st	Z, r18
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	40 83       	st	Z, r20
     80c:	31 97       	sbiw	r30, 0x01	; 1
     80e:	50 83       	st	Z, r21
     810:	31 97       	sbiw	r30, 0x01	; 1
     812:	26 e2       	ldi	r18, 0x26	; 38
     814:	20 83       	st	Z, r18
     816:	31 97       	sbiw	r30, 0x01	; 1
     818:	27 e2       	ldi	r18, 0x27	; 39
     81a:	20 83       	st	Z, r18
     81c:	31 97       	sbiw	r30, 0x01	; 1
     81e:	28 e2       	ldi	r18, 0x28	; 40
     820:	20 83       	st	Z, r18
     822:	31 97       	sbiw	r30, 0x01	; 1
     824:	29 e2       	ldi	r18, 0x29	; 41
     826:	20 83       	st	Z, r18
     828:	31 97       	sbiw	r30, 0x01	; 1
     82a:	20 e3       	ldi	r18, 0x30	; 48
     82c:	20 83       	st	Z, r18
     82e:	31 97       	sbiw	r30, 0x01	; 1
     830:	21 e3       	ldi	r18, 0x31	; 49
     832:	20 83       	st	Z, r18
     834:	86 97       	sbiw	r24, 0x26	; 38
     836:	08 95       	ret

00000838 <xPortStartScheduler>:
     838:	0e 94 a7 03 	call	0x74e	; 0x74e <prvSetupTimerInterrupt>
     83c:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
     840:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
     844:	cd 91       	ld	r28, X+
     846:	cd bf       	out	0x3d, r28	; 61
     848:	dd 91       	ld	r29, X+
     84a:	de bf       	out	0x3e, r29	; 62
     84c:	ff 91       	pop	r31
     84e:	ef 91       	pop	r30
     850:	df 91       	pop	r29
     852:	cf 91       	pop	r28
     854:	bf 91       	pop	r27
     856:	af 91       	pop	r26
     858:	9f 91       	pop	r25
     85a:	8f 91       	pop	r24
     85c:	7f 91       	pop	r23
     85e:	6f 91       	pop	r22
     860:	5f 91       	pop	r21
     862:	4f 91       	pop	r20
     864:	3f 91       	pop	r19
     866:	2f 91       	pop	r18
     868:	1f 91       	pop	r17
     86a:	0f 91       	pop	r16
     86c:	ff 90       	pop	r15
     86e:	ef 90       	pop	r14
     870:	df 90       	pop	r13
     872:	cf 90       	pop	r12
     874:	bf 90       	pop	r11
     876:	af 90       	pop	r10
     878:	9f 90       	pop	r9
     87a:	8f 90       	pop	r8
     87c:	7f 90       	pop	r7
     87e:	6f 90       	pop	r6
     880:	5f 90       	pop	r5
     882:	4f 90       	pop	r4
     884:	3f 90       	pop	r3
     886:	2f 90       	pop	r2
     888:	1f 90       	pop	r1
     88a:	0f 90       	pop	r0
     88c:	0f be       	out	0x3f, r0	; 63
     88e:	0f 90       	pop	r0
     890:	08 95       	ret
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	08 95       	ret

00000896 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     896:	0f 92       	push	r0
     898:	0f b6       	in	r0, 0x3f	; 63
     89a:	f8 94       	cli
     89c:	0f 92       	push	r0
     89e:	1f 92       	push	r1
     8a0:	11 24       	eor	r1, r1
     8a2:	2f 92       	push	r2
     8a4:	3f 92       	push	r3
     8a6:	4f 92       	push	r4
     8a8:	5f 92       	push	r5
     8aa:	6f 92       	push	r6
     8ac:	7f 92       	push	r7
     8ae:	8f 92       	push	r8
     8b0:	9f 92       	push	r9
     8b2:	af 92       	push	r10
     8b4:	bf 92       	push	r11
     8b6:	cf 92       	push	r12
     8b8:	df 92       	push	r13
     8ba:	ef 92       	push	r14
     8bc:	ff 92       	push	r15
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	2f 93       	push	r18
     8c4:	3f 93       	push	r19
     8c6:	4f 93       	push	r20
     8c8:	5f 93       	push	r21
     8ca:	6f 93       	push	r22
     8cc:	7f 93       	push	r23
     8ce:	8f 93       	push	r24
     8d0:	9f 93       	push	r25
     8d2:	af 93       	push	r26
     8d4:	bf 93       	push	r27
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	ef 93       	push	r30
     8dc:	ff 93       	push	r31
     8de:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
     8e2:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
     8e6:	0d b6       	in	r0, 0x3d	; 61
     8e8:	0d 92       	st	X+, r0
     8ea:	0e b6       	in	r0, 0x3e	; 62
     8ec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     8ee:	0e 94 1a 0b 	call	0x1634	; 0x1634 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     8f2:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
     8f6:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
     8fa:	cd 91       	ld	r28, X+
     8fc:	cd bf       	out	0x3d, r28	; 61
     8fe:	dd 91       	ld	r29, X+
     900:	de bf       	out	0x3e, r29	; 62
     902:	ff 91       	pop	r31
     904:	ef 91       	pop	r30
     906:	df 91       	pop	r29
     908:	cf 91       	pop	r28
     90a:	bf 91       	pop	r27
     90c:	af 91       	pop	r26
     90e:	9f 91       	pop	r25
     910:	8f 91       	pop	r24
     912:	7f 91       	pop	r23
     914:	6f 91       	pop	r22
     916:	5f 91       	pop	r21
     918:	4f 91       	pop	r20
     91a:	3f 91       	pop	r19
     91c:	2f 91       	pop	r18
     91e:	1f 91       	pop	r17
     920:	0f 91       	pop	r16
     922:	ff 90       	pop	r15
     924:	ef 90       	pop	r14
     926:	df 90       	pop	r13
     928:	cf 90       	pop	r12
     92a:	bf 90       	pop	r11
     92c:	af 90       	pop	r10
     92e:	9f 90       	pop	r9
     930:	8f 90       	pop	r8
     932:	7f 90       	pop	r7
     934:	6f 90       	pop	r6
     936:	5f 90       	pop	r5
     938:	4f 90       	pop	r4
     93a:	3f 90       	pop	r3
     93c:	2f 90       	pop	r2
     93e:	1f 90       	pop	r1
     940:	0f 90       	pop	r0
     942:	0f be       	out	0x3f, r0	; 63
     944:	0f 90       	pop	r0

	asm volatile ( "ret" );
     946:	08 95       	ret

00000948 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     948:	0f 92       	push	r0
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	f8 94       	cli
     94e:	0f 92       	push	r0
     950:	1f 92       	push	r1
     952:	11 24       	eor	r1, r1
     954:	2f 92       	push	r2
     956:	3f 92       	push	r3
     958:	4f 92       	push	r4
     95a:	5f 92       	push	r5
     95c:	6f 92       	push	r6
     95e:	7f 92       	push	r7
     960:	8f 92       	push	r8
     962:	9f 92       	push	r9
     964:	af 92       	push	r10
     966:	bf 92       	push	r11
     968:	cf 92       	push	r12
     96a:	df 92       	push	r13
     96c:	ef 92       	push	r14
     96e:	ff 92       	push	r15
     970:	0f 93       	push	r16
     972:	1f 93       	push	r17
     974:	2f 93       	push	r18
     976:	3f 93       	push	r19
     978:	4f 93       	push	r20
     97a:	5f 93       	push	r21
     97c:	6f 93       	push	r22
     97e:	7f 93       	push	r23
     980:	8f 93       	push	r24
     982:	9f 93       	push	r25
     984:	af 93       	push	r26
     986:	bf 93       	push	r27
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ef 93       	push	r30
     98e:	ff 93       	push	r31
     990:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
     994:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
     998:	0d b6       	in	r0, 0x3d	; 61
     99a:	0d 92       	st	X+, r0
     99c:	0e b6       	in	r0, 0x3e	; 62
     99e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     9a0:	0e 94 a7 09 	call	0x134e	; 0x134e <xTaskIncrementTick>
     9a4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     9a6:	0e 94 1a 0b 	call	0x1634	; 0x1634 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     9aa:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
     9ae:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
     9b2:	cd 91       	ld	r28, X+
     9b4:	cd bf       	out	0x3d, r28	; 61
     9b6:	dd 91       	ld	r29, X+
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	ff 91       	pop	r31
     9bc:	ef 91       	pop	r30
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	bf 91       	pop	r27
     9c4:	af 91       	pop	r26
     9c6:	9f 91       	pop	r25
     9c8:	8f 91       	pop	r24
     9ca:	7f 91       	pop	r23
     9cc:	6f 91       	pop	r22
     9ce:	5f 91       	pop	r21
     9d0:	4f 91       	pop	r20
     9d2:	3f 91       	pop	r19
     9d4:	2f 91       	pop	r18
     9d6:	1f 91       	pop	r17
     9d8:	0f 91       	pop	r16
     9da:	ff 90       	pop	r15
     9dc:	ef 90       	pop	r14
     9de:	df 90       	pop	r13
     9e0:	cf 90       	pop	r12
     9e2:	bf 90       	pop	r11
     9e4:	af 90       	pop	r10
     9e6:	9f 90       	pop	r9
     9e8:	8f 90       	pop	r8
     9ea:	7f 90       	pop	r7
     9ec:	6f 90       	pop	r6
     9ee:	5f 90       	pop	r5
     9f0:	4f 90       	pop	r4
     9f2:	3f 90       	pop	r3
     9f4:	2f 90       	pop	r2
     9f6:	1f 90       	pop	r1
     9f8:	0f 90       	pop	r0
     9fa:	0f be       	out	0x3f, r0	; 63
     9fc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9fe:	08 95       	ret

00000a00 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     a00:	0e 94 a4 04 	call	0x948	; 0x948 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a04:	18 95       	reti

00000a06 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     a06:	0f b6       	in	r0, 0x3f	; 63
     a08:	f8 94       	cli
     a0a:	0f 92       	push	r0
     a0c:	fc 01       	movw	r30, r24
     a0e:	82 8d       	ldd	r24, Z+26	; 0x1a
     a10:	81 11       	cpse	r24, r1
     a12:	02 c0       	rjmp	.+4      	; 0xa18 <prvIsQueueEmpty+0x12>
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <prvIsQueueEmpty+0x14>
     a18:	80 e0       	ldi	r24, 0x00	; 0
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	08 95       	ret

00000a20 <prvIsQueueFull>:
     a20:	0f b6       	in	r0, 0x3f	; 63
     a22:	f8 94       	cli
     a24:	0f 92       	push	r0
     a26:	fc 01       	movw	r30, r24
     a28:	22 8d       	ldd	r18, Z+26	; 0x1a
     a2a:	83 8d       	ldd	r24, Z+27	; 0x1b
     a2c:	28 13       	cpse	r18, r24
     a2e:	02 c0       	rjmp	.+4      	; 0xa34 <prvIsQueueFull+0x14>
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	01 c0       	rjmp	.+2      	; 0xa36 <prvIsQueueFull+0x16>
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
     a3a:	08 95       	ret

00000a3c <prvCopyDataToQueue>:
     a3c:	0f 93       	push	r16
     a3e:	1f 93       	push	r17
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	ec 01       	movw	r28, r24
     a46:	04 2f       	mov	r16, r20
     a48:	1a 8d       	ldd	r17, Y+26	; 0x1a
     a4a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a4c:	41 11       	cpse	r20, r1
     a4e:	0c c0       	rjmp	.+24     	; 0xa68 <prvCopyDataToQueue+0x2c>
     a50:	88 81       	ld	r24, Y
     a52:	99 81       	ldd	r25, Y+1	; 0x01
     a54:	89 2b       	or	r24, r25
     a56:	09 f0       	breq	.+2      	; 0xa5a <prvCopyDataToQueue+0x1e>
     a58:	42 c0       	rjmp	.+132    	; 0xade <prvCopyDataToQueue+0xa2>
     a5a:	8a 81       	ldd	r24, Y+2	; 0x02
     a5c:	9b 81       	ldd	r25, Y+3	; 0x03
     a5e:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <xTaskPriorityDisinherit>
     a62:	1b 82       	std	Y+3, r1	; 0x03
     a64:	1a 82       	std	Y+2, r1	; 0x02
     a66:	42 c0       	rjmp	.+132    	; 0xaec <prvCopyDataToQueue+0xb0>
     a68:	01 11       	cpse	r16, r1
     a6a:	17 c0       	rjmp	.+46     	; 0xa9a <prvCopyDataToQueue+0x5e>
     a6c:	50 e0       	ldi	r21, 0x00	; 0
     a6e:	8c 81       	ldd	r24, Y+4	; 0x04
     a70:	9d 81       	ldd	r25, Y+5	; 0x05
     a72:	0e 94 44 11 	call	0x2288	; 0x2288 <memcpy>
     a76:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a78:	8c 81       	ldd	r24, Y+4	; 0x04
     a7a:	9d 81       	ldd	r25, Y+5	; 0x05
     a7c:	82 0f       	add	r24, r18
     a7e:	91 1d       	adc	r25, r1
     a80:	9d 83       	std	Y+5, r25	; 0x05
     a82:	8c 83       	std	Y+4, r24	; 0x04
     a84:	2a 81       	ldd	r18, Y+2	; 0x02
     a86:	3b 81       	ldd	r19, Y+3	; 0x03
     a88:	82 17       	cp	r24, r18
     a8a:	93 07       	cpc	r25, r19
     a8c:	50 f1       	brcs	.+84     	; 0xae2 <prvCopyDataToQueue+0xa6>
     a8e:	88 81       	ld	r24, Y
     a90:	99 81       	ldd	r25, Y+1	; 0x01
     a92:	9d 83       	std	Y+5, r25	; 0x05
     a94:	8c 83       	std	Y+4, r24	; 0x04
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	29 c0       	rjmp	.+82     	; 0xaec <prvCopyDataToQueue+0xb0>
     a9a:	50 e0       	ldi	r21, 0x00	; 0
     a9c:	8e 81       	ldd	r24, Y+6	; 0x06
     a9e:	9f 81       	ldd	r25, Y+7	; 0x07
     aa0:	0e 94 44 11 	call	0x2288	; 0x2288 <memcpy>
     aa4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	91 95       	neg	r25
     aaa:	81 95       	neg	r24
     aac:	91 09       	sbc	r25, r1
     aae:	2e 81       	ldd	r18, Y+6	; 0x06
     ab0:	3f 81       	ldd	r19, Y+7	; 0x07
     ab2:	28 0f       	add	r18, r24
     ab4:	39 1f       	adc	r19, r25
     ab6:	3f 83       	std	Y+7, r19	; 0x07
     ab8:	2e 83       	std	Y+6, r18	; 0x06
     aba:	48 81       	ld	r20, Y
     abc:	59 81       	ldd	r21, Y+1	; 0x01
     abe:	24 17       	cp	r18, r20
     ac0:	35 07       	cpc	r19, r21
     ac2:	30 f4       	brcc	.+12     	; 0xad0 <prvCopyDataToQueue+0x94>
     ac4:	2a 81       	ldd	r18, Y+2	; 0x02
     ac6:	3b 81       	ldd	r19, Y+3	; 0x03
     ac8:	82 0f       	add	r24, r18
     aca:	93 1f       	adc	r25, r19
     acc:	9f 83       	std	Y+7, r25	; 0x07
     ace:	8e 83       	std	Y+6, r24	; 0x06
     ad0:	02 30       	cpi	r16, 0x02	; 2
     ad2:	49 f4       	brne	.+18     	; 0xae6 <prvCopyDataToQueue+0xaa>
     ad4:	11 23       	and	r17, r17
     ad6:	49 f0       	breq	.+18     	; 0xaea <prvCopyDataToQueue+0xae>
     ad8:	11 50       	subi	r17, 0x01	; 1
     ada:	80 e0       	ldi	r24, 0x00	; 0
     adc:	07 c0       	rjmp	.+14     	; 0xaec <prvCopyDataToQueue+0xb0>
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	05 c0       	rjmp	.+10     	; 0xaec <prvCopyDataToQueue+0xb0>
     ae2:	80 e0       	ldi	r24, 0x00	; 0
     ae4:	03 c0       	rjmp	.+6      	; 0xaec <prvCopyDataToQueue+0xb0>
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	01 c0       	rjmp	.+2      	; 0xaec <prvCopyDataToQueue+0xb0>
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	1f 5f       	subi	r17, 0xFF	; 255
     aee:	1a 8f       	std	Y+26, r17	; 0x1a
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	1f 91       	pop	r17
     af6:	0f 91       	pop	r16
     af8:	08 95       	ret

00000afa <prvCopyDataFromQueue>:
     afa:	fc 01       	movw	r30, r24
     afc:	44 8d       	ldd	r20, Z+28	; 0x1c
     afe:	44 23       	and	r20, r20
     b00:	a9 f0       	breq	.+42     	; 0xb2c <prvCopyDataFromQueue+0x32>
     b02:	50 e0       	ldi	r21, 0x00	; 0
     b04:	26 81       	ldd	r18, Z+6	; 0x06
     b06:	37 81       	ldd	r19, Z+7	; 0x07
     b08:	24 0f       	add	r18, r20
     b0a:	35 1f       	adc	r19, r21
     b0c:	37 83       	std	Z+7, r19	; 0x07
     b0e:	26 83       	std	Z+6, r18	; 0x06
     b10:	82 81       	ldd	r24, Z+2	; 0x02
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	28 17       	cp	r18, r24
     b16:	39 07       	cpc	r19, r25
     b18:	20 f0       	brcs	.+8      	; 0xb22 <prvCopyDataFromQueue+0x28>
     b1a:	80 81       	ld	r24, Z
     b1c:	91 81       	ldd	r25, Z+1	; 0x01
     b1e:	97 83       	std	Z+7, r25	; 0x07
     b20:	86 83       	std	Z+6, r24	; 0x06
     b22:	cb 01       	movw	r24, r22
     b24:	66 81       	ldd	r22, Z+6	; 0x06
     b26:	77 81       	ldd	r23, Z+7	; 0x07
     b28:	0e 94 44 11 	call	0x2288	; 0x2288 <memcpy>
     b2c:	08 95       	ret

00000b2e <prvUnlockQueue>:
     b2e:	1f 93       	push	r17
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	ec 01       	movw	r28, r24
     b36:	0f b6       	in	r0, 0x3f	; 63
     b38:	f8 94       	cli
     b3a:	0f 92       	push	r0
     b3c:	1e 8d       	ldd	r17, Y+30	; 0x1e
     b3e:	0b c0       	rjmp	.+22     	; 0xb56 <prvUnlockQueue+0x28>
     b40:	89 89       	ldd	r24, Y+17	; 0x11
     b42:	88 23       	and	r24, r24
     b44:	51 f0       	breq	.+20     	; 0xb5a <prvUnlockQueue+0x2c>
     b46:	ce 01       	movw	r24, r28
     b48:	41 96       	adiw	r24, 0x11	; 17
     b4a:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     b4e:	81 11       	cpse	r24, r1
     b50:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vTaskMissedYield>
     b54:	11 50       	subi	r17, 0x01	; 1
     b56:	11 16       	cp	r1, r17
     b58:	9c f3       	brlt	.-26     	; 0xb40 <prvUnlockQueue+0x12>
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	8e 8f       	std	Y+30, r24	; 0x1e
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	0f b6       	in	r0, 0x3f	; 63
     b64:	f8 94       	cli
     b66:	0f 92       	push	r0
     b68:	1d 8d       	ldd	r17, Y+29	; 0x1d
     b6a:	0b c0       	rjmp	.+22     	; 0xb82 <prvUnlockQueue+0x54>
     b6c:	88 85       	ldd	r24, Y+8	; 0x08
     b6e:	88 23       	and	r24, r24
     b70:	51 f0       	breq	.+20     	; 0xb86 <prvUnlockQueue+0x58>
     b72:	ce 01       	movw	r24, r28
     b74:	08 96       	adiw	r24, 0x08	; 8
     b76:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     b7a:	81 11       	cpse	r24, r1
     b7c:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vTaskMissedYield>
     b80:	11 50       	subi	r17, 0x01	; 1
     b82:	11 16       	cp	r1, r17
     b84:	9c f3       	brlt	.-26     	; 0xb6c <prvUnlockQueue+0x3e>
     b86:	8f ef       	ldi	r24, 0xFF	; 255
     b88:	8d 8f       	std	Y+29, r24	; 0x1d
     b8a:	0f 90       	pop	r0
     b8c:	0f be       	out	0x3f, r0	; 63
     b8e:	df 91       	pop	r29
     b90:	cf 91       	pop	r28
     b92:	1f 91       	pop	r17
     b94:	08 95       	ret

00000b96 <xQueueGenericReset>:
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	ec 01       	movw	r28, r24
     b9c:	0f b6       	in	r0, 0x3f	; 63
     b9e:	f8 94       	cli
     ba0:	0f 92       	push	r0
     ba2:	e8 81       	ld	r30, Y
     ba4:	f9 81       	ldd	r31, Y+1	; 0x01
     ba6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bac:	30 e0       	ldi	r19, 0x00	; 0
     bae:	82 9f       	mul	r24, r18
     bb0:	a0 01       	movw	r20, r0
     bb2:	83 9f       	mul	r24, r19
     bb4:	50 0d       	add	r21, r0
     bb6:	92 9f       	mul	r25, r18
     bb8:	50 0d       	add	r21, r0
     bba:	11 24       	eor	r1, r1
     bbc:	4e 0f       	add	r20, r30
     bbe:	5f 1f       	adc	r21, r31
     bc0:	5b 83       	std	Y+3, r21	; 0x03
     bc2:	4a 83       	std	Y+2, r20	; 0x02
     bc4:	1a 8e       	std	Y+26, r1	; 0x1a
     bc6:	fd 83       	std	Y+5, r31	; 0x05
     bc8:	ec 83       	std	Y+4, r30	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	28 9f       	mul	r18, r24
     bce:	a0 01       	movw	r20, r0
     bd0:	29 9f       	mul	r18, r25
     bd2:	50 0d       	add	r21, r0
     bd4:	38 9f       	mul	r19, r24
     bd6:	50 0d       	add	r21, r0
     bd8:	11 24       	eor	r1, r1
     bda:	cf 01       	movw	r24, r30
     bdc:	84 0f       	add	r24, r20
     bde:	95 1f       	adc	r25, r21
     be0:	9f 83       	std	Y+7, r25	; 0x07
     be2:	8e 83       	std	Y+6, r24	; 0x06
     be4:	8f ef       	ldi	r24, 0xFF	; 255
     be6:	8d 8f       	std	Y+29, r24	; 0x1d
     be8:	8e 8f       	std	Y+30, r24	; 0x1e
     bea:	61 11       	cpse	r22, r1
     bec:	0c c0       	rjmp	.+24     	; 0xc06 <xQueueGenericReset+0x70>
     bee:	88 85       	ldd	r24, Y+8	; 0x08
     bf0:	88 23       	and	r24, r24
     bf2:	89 f0       	breq	.+34     	; 0xc16 <xQueueGenericReset+0x80>
     bf4:	ce 01       	movw	r24, r28
     bf6:	08 96       	adiw	r24, 0x08	; 8
     bf8:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     bfc:	88 23       	and	r24, r24
     bfe:	59 f0       	breq	.+22     	; 0xc16 <xQueueGenericReset+0x80>
     c00:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     c04:	08 c0       	rjmp	.+16     	; 0xc16 <xQueueGenericReset+0x80>
     c06:	ce 01       	movw	r24, r28
     c08:	08 96       	adiw	r24, 0x08	; 8
     c0a:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
     c0e:	ce 01       	movw	r24, r28
     c10:	41 96       	adiw	r24, 0x11	; 17
     c12:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
     c16:	0f 90       	pop	r0
     c18:	0f be       	out	0x3f, r0	; 63
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	08 95       	ret

00000c22 <prvInitialiseNewQueue>:
     c22:	0f 93       	push	r16
     c24:	1f 93       	push	r17
     c26:	f8 01       	movw	r30, r16
     c28:	61 11       	cpse	r22, r1
     c2a:	03 c0       	rjmp	.+6      	; 0xc32 <prvInitialiseNewQueue+0x10>
     c2c:	11 83       	std	Z+1, r17	; 0x01
     c2e:	00 83       	st	Z, r16
     c30:	02 c0       	rjmp	.+4      	; 0xc36 <prvInitialiseNewQueue+0x14>
     c32:	51 83       	std	Z+1, r21	; 0x01
     c34:	40 83       	st	Z, r20
     c36:	83 8f       	std	Z+27, r24	; 0x1b
     c38:	64 8f       	std	Z+28, r22	; 0x1c
     c3a:	61 e0       	ldi	r22, 0x01	; 1
     c3c:	cf 01       	movw	r24, r30
     c3e:	0e 94 cb 05 	call	0xb96	; 0xb96 <xQueueGenericReset>
     c42:	1f 91       	pop	r17
     c44:	0f 91       	pop	r16
     c46:	08 95       	ret

00000c48 <xQueueGenericCreate>:
     c48:	df 92       	push	r13
     c4a:	ef 92       	push	r14
     c4c:	ff 92       	push	r15
     c4e:	0f 93       	push	r16
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
     c56:	e8 2e       	mov	r14, r24
     c58:	f6 2e       	mov	r15, r22
     c5a:	d4 2e       	mov	r13, r20
     c5c:	66 23       	and	r22, r22
     c5e:	21 f0       	breq	.+8      	; 0xc68 <xQueueGenericCreate+0x20>
     c60:	86 9f       	mul	r24, r22
     c62:	c0 01       	movw	r24, r0
     c64:	11 24       	eor	r1, r1
     c66:	02 c0       	rjmp	.+4      	; 0xc6c <xQueueGenericCreate+0x24>
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	4f 96       	adiw	r24, 0x1f	; 31
     c6e:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
     c72:	ec 01       	movw	r28, r24
     c74:	00 97       	sbiw	r24, 0x00	; 0
     c76:	49 f0       	breq	.+18     	; 0xc8a <xQueueGenericCreate+0x42>
     c78:	8c 01       	movw	r16, r24
     c7a:	2d 2d       	mov	r18, r13
     c7c:	ac 01       	movw	r20, r24
     c7e:	41 5e       	subi	r20, 0xE1	; 225
     c80:	5f 4f       	sbci	r21, 0xFF	; 255
     c82:	6f 2d       	mov	r22, r15
     c84:	8e 2d       	mov	r24, r14
     c86:	0e 94 11 06 	call	0xc22	; 0xc22 <prvInitialiseNewQueue>
     c8a:	ce 01       	movw	r24, r28
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	08 95       	ret

00000c9c <xQueueGenericSend>:
     c9c:	cf 92       	push	r12
     c9e:	df 92       	push	r13
     ca0:	ef 92       	push	r14
     ca2:	ff 92       	push	r15
     ca4:	0f 93       	push	r16
     ca6:	1f 93       	push	r17
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	00 d0       	rcall	.+0      	; 0xcae <xQueueGenericSend+0x12>
     cae:	00 d0       	rcall	.+0      	; 0xcb0 <xQueueGenericSend+0x14>
     cb0:	1f 92       	push	r1
     cb2:	cd b7       	in	r28, 0x3d	; 61
     cb4:	de b7       	in	r29, 0x3e	; 62
     cb6:	8c 01       	movw	r16, r24
     cb8:	7b 01       	movw	r14, r22
     cba:	5d 83       	std	Y+5, r21	; 0x05
     cbc:	4c 83       	std	Y+4, r20	; 0x04
     cbe:	c2 2e       	mov	r12, r18
     cc0:	d1 2c       	mov	r13, r1
     cc2:	0f b6       	in	r0, 0x3f	; 63
     cc4:	f8 94       	cli
     cc6:	0f 92       	push	r0
     cc8:	f8 01       	movw	r30, r16
     cca:	92 8d       	ldd	r25, Z+26	; 0x1a
     ccc:	83 8d       	ldd	r24, Z+27	; 0x1b
     cce:	98 17       	cp	r25, r24
     cd0:	18 f0       	brcs	.+6      	; 0xcd8 <xQueueGenericSend+0x3c>
     cd2:	f2 e0       	ldi	r31, 0x02	; 2
     cd4:	cf 12       	cpse	r12, r31
     cd6:	19 c0       	rjmp	.+50     	; 0xd0a <xQueueGenericSend+0x6e>
     cd8:	4c 2d       	mov	r20, r12
     cda:	b7 01       	movw	r22, r14
     cdc:	c8 01       	movw	r24, r16
     cde:	0e 94 1e 05 	call	0xa3c	; 0xa3c <prvCopyDataToQueue>
     ce2:	f8 01       	movw	r30, r16
     ce4:	91 89       	ldd	r25, Z+17	; 0x11
     ce6:	99 23       	and	r25, r25
     ce8:	49 f0       	breq	.+18     	; 0xcfc <xQueueGenericSend+0x60>
     cea:	c8 01       	movw	r24, r16
     cec:	41 96       	adiw	r24, 0x11	; 17
     cee:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     cf2:	88 23       	and	r24, r24
     cf4:	31 f0       	breq	.+12     	; 0xd02 <xQueueGenericSend+0x66>
     cf6:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     cfa:	03 c0       	rjmp	.+6      	; 0xd02 <xQueueGenericSend+0x66>
     cfc:	81 11       	cpse	r24, r1
     cfe:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     d02:	0f 90       	pop	r0
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	4d c0       	rjmp	.+154    	; 0xda4 <xQueueGenericSend+0x108>
     d0a:	8c 81       	ldd	r24, Y+4	; 0x04
     d0c:	9d 81       	ldd	r25, Y+5	; 0x05
     d0e:	89 2b       	or	r24, r25
     d10:	21 f4       	brne	.+8      	; 0xd1a <xQueueGenericSend+0x7e>
     d12:	0f 90       	pop	r0
     d14:	0f be       	out	0x3f, r0	; 63
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	45 c0       	rjmp	.+138    	; 0xda4 <xQueueGenericSend+0x108>
     d1a:	d1 10       	cpse	r13, r1
     d1c:	06 c0       	rjmp	.+12     	; 0xd2a <xQueueGenericSend+0x8e>
     d1e:	ce 01       	movw	r24, r28
     d20:	01 96       	adiw	r24, 0x01	; 1
     d22:	0e 94 c8 0b 	call	0x1790	; 0x1790 <vTaskSetTimeOutState>
     d26:	dd 24       	eor	r13, r13
     d28:	d3 94       	inc	r13
     d2a:	0f 90       	pop	r0
     d2c:	0f be       	out	0x3f, r0	; 63
     d2e:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	f8 94       	cli
     d36:	0f 92       	push	r0
     d38:	f8 01       	movw	r30, r16
     d3a:	85 8d       	ldd	r24, Z+29	; 0x1d
     d3c:	8f 3f       	cpi	r24, 0xFF	; 255
     d3e:	09 f4       	brne	.+2      	; 0xd42 <xQueueGenericSend+0xa6>
     d40:	15 8e       	std	Z+29, r1	; 0x1d
     d42:	f8 01       	movw	r30, r16
     d44:	86 8d       	ldd	r24, Z+30	; 0x1e
     d46:	8f 3f       	cpi	r24, 0xFF	; 255
     d48:	09 f4       	brne	.+2      	; 0xd4c <xQueueGenericSend+0xb0>
     d4a:	16 8e       	std	Z+30, r1	; 0x1e
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	be 01       	movw	r22, r28
     d52:	6c 5f       	subi	r22, 0xFC	; 252
     d54:	7f 4f       	sbci	r23, 0xFF	; 255
     d56:	ce 01       	movw	r24, r28
     d58:	01 96       	adiw	r24, 0x01	; 1
     d5a:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <xTaskCheckForTimeOut>
     d5e:	81 11       	cpse	r24, r1
     d60:	1b c0       	rjmp	.+54     	; 0xd98 <xQueueGenericSend+0xfc>
     d62:	c8 01       	movw	r24, r16
     d64:	0e 94 10 05 	call	0xa20	; 0xa20 <prvIsQueueFull>
     d68:	88 23       	and	r24, r24
     d6a:	81 f0       	breq	.+32     	; 0xd8c <xQueueGenericSend+0xf0>
     d6c:	6c 81       	ldd	r22, Y+4	; 0x04
     d6e:	7d 81       	ldd	r23, Y+5	; 0x05
     d70:	c8 01       	movw	r24, r16
     d72:	08 96       	adiw	r24, 0x08	; 8
     d74:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vTaskPlaceOnEventList>
     d78:	c8 01       	movw	r24, r16
     d7a:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
     d7e:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
     d82:	81 11       	cpse	r24, r1
     d84:	9e cf       	rjmp	.-196    	; 0xcc2 <xQueueGenericSend+0x26>
     d86:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     d8a:	9b cf       	rjmp	.-202    	; 0xcc2 <xQueueGenericSend+0x26>
     d8c:	c8 01       	movw	r24, r16
     d8e:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
     d92:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
     d96:	95 cf       	rjmp	.-214    	; 0xcc2 <xQueueGenericSend+0x26>
     d98:	c8 01       	movw	r24, r16
     d9a:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
     d9e:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
     da2:	80 e0       	ldi	r24, 0x00	; 0
     da4:	0f 90       	pop	r0
     da6:	0f 90       	pop	r0
     da8:	0f 90       	pop	r0
     daa:	0f 90       	pop	r0
     dac:	0f 90       	pop	r0
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	df 90       	pop	r13
     dbc:	cf 90       	pop	r12
     dbe:	08 95       	ret

00000dc0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     dc0:	8f 92       	push	r8
     dc2:	9f 92       	push	r9
     dc4:	bf 92       	push	r11
     dc6:	cf 92       	push	r12
     dc8:	df 92       	push	r13
     dca:	ef 92       	push	r14
     dcc:	ff 92       	push	r15
     dce:	0f 93       	push	r16
     dd0:	1f 93       	push	r17
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	00 d0       	rcall	.+0      	; 0xdd8 <xQueueGenericReceive+0x18>
     dd8:	00 d0       	rcall	.+0      	; 0xdda <xQueueGenericReceive+0x1a>
     dda:	1f 92       	push	r1
     ddc:	cd b7       	in	r28, 0x3d	; 61
     dde:	de b7       	in	r29, 0x3e	; 62
     de0:	8c 01       	movw	r16, r24
     de2:	6b 01       	movw	r12, r22
     de4:	5d 83       	std	Y+5, r21	; 0x05
     de6:	4c 83       	std	Y+4, r20	; 0x04
     de8:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     dea:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     dec:	0f b6       	in	r0, 0x3f	; 63
     dee:	f8 94       	cli
     df0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     df2:	f8 01       	movw	r30, r16
     df4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     df6:	ff 20       	and	r15, r15
     df8:	91 f1       	breq	.+100    	; 0xe5e <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     dfa:	86 80       	ldd	r8, Z+6	; 0x06
     dfc:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dfe:	b6 01       	movw	r22, r12
     e00:	c8 01       	movw	r24, r16
     e02:	0e 94 7d 05 	call	0xafa	; 0xafa <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     e06:	b1 10       	cpse	r11, r1
     e08:	19 c0       	rjmp	.+50     	; 0xe3c <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     e0a:	fa 94       	dec	r15
     e0c:	f8 01       	movw	r30, r16
     e0e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e10:	80 81       	ld	r24, Z
     e12:	91 81       	ldd	r25, Z+1	; 0x01
     e14:	89 2b       	or	r24, r25
     e16:	29 f4       	brne	.+10     	; 0xe22 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     e18:	0e 94 b2 0c 	call	0x1964	; 0x1964 <pvTaskIncrementMutexHeldCount>
     e1c:	f8 01       	movw	r30, r16
     e1e:	93 83       	std	Z+3, r25	; 0x03
     e20:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e22:	f8 01       	movw	r30, r16
     e24:	80 85       	ldd	r24, Z+8	; 0x08
     e26:	88 23       	and	r24, r24
     e28:	b1 f0       	breq	.+44     	; 0xe56 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e2a:	c8 01       	movw	r24, r16
     e2c:	08 96       	adiw	r24, 0x08	; 8
     e2e:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     e32:	88 23       	and	r24, r24
     e34:	81 f0       	breq	.+32     	; 0xe56 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     e36:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     e3a:	0d c0       	rjmp	.+26     	; 0xe56 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     e3c:	f8 01       	movw	r30, r16
     e3e:	97 82       	std	Z+7, r9	; 0x07
     e40:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e42:	81 89       	ldd	r24, Z+17	; 0x11
     e44:	88 23       	and	r24, r24
     e46:	39 f0       	breq	.+14     	; 0xe56 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e48:	c8 01       	movw	r24, r16
     e4a:	41 96       	adiw	r24, 0x11	; 17
     e4c:	0e 94 80 0b 	call	0x1700	; 0x1700 <xTaskRemoveFromEventList>
     e50:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e52:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	61 c0       	rjmp	.+194    	; 0xf20 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e5e:	8c 81       	ldd	r24, Y+4	; 0x04
     e60:	9d 81       	ldd	r25, Y+5	; 0x05
     e62:	89 2b       	or	r24, r25
     e64:	21 f4       	brne	.+8      	; 0xe6e <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e66:	0f 90       	pop	r0
     e68:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e6a:	80 e0       	ldi	r24, 0x00	; 0
     e6c:	59 c0       	rjmp	.+178    	; 0xf20 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
     e6e:	e1 10       	cpse	r14, r1
     e70:	06 c0       	rjmp	.+12     	; 0xe7e <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e72:	ce 01       	movw	r24, r28
     e74:	01 96       	adiw	r24, 0x01	; 1
     e76:	0e 94 c8 0b 	call	0x1790	; 0x1790 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e7a:	ee 24       	eor	r14, r14
     e7c:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e82:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	0f 92       	push	r0
     e8c:	f8 01       	movw	r30, r16
     e8e:	85 8d       	ldd	r24, Z+29	; 0x1d
     e90:	8f 3f       	cpi	r24, 0xFF	; 255
     e92:	09 f4       	brne	.+2      	; 0xe96 <xQueueGenericReceive+0xd6>
     e94:	15 8e       	std	Z+29, r1	; 0x1d
     e96:	f8 01       	movw	r30, r16
     e98:	86 8d       	ldd	r24, Z+30	; 0x1e
     e9a:	8f 3f       	cpi	r24, 0xFF	; 255
     e9c:	09 f4       	brne	.+2      	; 0xea0 <xQueueGenericReceive+0xe0>
     e9e:	16 8e       	std	Z+30, r1	; 0x1e
     ea0:	0f 90       	pop	r0
     ea2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ea4:	be 01       	movw	r22, r28
     ea6:	6c 5f       	subi	r22, 0xFC	; 252
     ea8:	7f 4f       	sbci	r23, 0xFF	; 255
     eaa:	ce 01       	movw	r24, r28
     eac:	01 96       	adiw	r24, 0x01	; 1
     eae:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <xTaskCheckForTimeOut>
     eb2:	81 11       	cpse	r24, r1
     eb4:	29 c0       	rjmp	.+82     	; 0xf08 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     eb6:	c8 01       	movw	r24, r16
     eb8:	0e 94 03 05 	call	0xa06	; 0xa06 <prvIsQueueEmpty>
     ebc:	88 23       	and	r24, r24
     ebe:	f1 f0       	breq	.+60     	; 0xefc <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ec0:	f8 01       	movw	r30, r16
     ec2:	80 81       	ld	r24, Z
     ec4:	91 81       	ldd	r25, Z+1	; 0x01
     ec6:	89 2b       	or	r24, r25
     ec8:	49 f4       	brne	.+18     	; 0xedc <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	f8 94       	cli
     ece:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     ed0:	82 81       	ldd	r24, Z+2	; 0x02
     ed2:	93 81       	ldd	r25, Z+3	; 0x03
     ed4:	0e 94 10 0c 	call	0x1820	; 0x1820 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     ed8:	0f 90       	pop	r0
     eda:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     edc:	6c 81       	ldd	r22, Y+4	; 0x04
     ede:	7d 81       	ldd	r23, Y+5	; 0x05
     ee0:	c8 01       	movw	r24, r16
     ee2:	41 96       	adiw	r24, 0x11	; 17
     ee4:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     ee8:	c8 01       	movw	r24, r16
     eea:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     eee:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
     ef2:	81 11       	cpse	r24, r1
     ef4:	7b cf       	rjmp	.-266    	; 0xdec <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
     ef6:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
     efa:	78 cf       	rjmp	.-272    	; 0xdec <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     efc:	c8 01       	movw	r24, r16
     efe:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f02:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
     f06:	72 cf       	rjmp	.-284    	; 0xdec <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     f08:	c8 01       	movw	r24, r16
     f0a:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f0e:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f12:	c8 01       	movw	r24, r16
     f14:	0e 94 03 05 	call	0xa06	; 0xa06 <prvIsQueueEmpty>
     f18:	88 23       	and	r24, r24
     f1a:	09 f4       	brne	.+2      	; 0xf1e <xQueueGenericReceive+0x15e>
     f1c:	67 cf       	rjmp	.-306    	; 0xdec <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     f1e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     f20:	0f 90       	pop	r0
     f22:	0f 90       	pop	r0
     f24:	0f 90       	pop	r0
     f26:	0f 90       	pop	r0
     f28:	0f 90       	pop	r0
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	1f 91       	pop	r17
     f30:	0f 91       	pop	r16
     f32:	ff 90       	pop	r15
     f34:	ef 90       	pop	r14
     f36:	df 90       	pop	r13
     f38:	cf 90       	pop	r12
     f3a:	bf 90       	pop	r11
     f3c:	9f 90       	pop	r9
     f3e:	8f 90       	pop	r8
     f40:	08 95       	ret

00000f42 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     f42:	e0 91 1d 05 	lds	r30, 0x051D	; 0x80051d <pxDelayedTaskList>
     f46:	f0 91 1e 05 	lds	r31, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
     f4a:	80 81       	ld	r24, Z
     f4c:	81 11       	cpse	r24, r1
     f4e:	07 c0       	rjmp	.+14     	; 0xf5e <prvResetNextTaskUnblockTime+0x1c>
     f50:	8f ef       	ldi	r24, 0xFF	; 255
     f52:	9f ef       	ldi	r25, 0xFF	; 255
     f54:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <xNextTaskUnblockTime+0x1>
     f58:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <xNextTaskUnblockTime>
     f5c:	08 95       	ret
     f5e:	e0 91 1d 05 	lds	r30, 0x051D	; 0x80051d <pxDelayedTaskList>
     f62:	f0 91 1e 05 	lds	r31, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
     f66:	05 80       	ldd	r0, Z+5	; 0x05
     f68:	f6 81       	ldd	r31, Z+6	; 0x06
     f6a:	e0 2d       	mov	r30, r0
     f6c:	06 80       	ldd	r0, Z+6	; 0x06
     f6e:	f7 81       	ldd	r31, Z+7	; 0x07
     f70:	e0 2d       	mov	r30, r0
     f72:	82 81       	ldd	r24, Z+2	; 0x02
     f74:	93 81       	ldd	r25, Z+3	; 0x03
     f76:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <xNextTaskUnblockTime+0x1>
     f7a:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <xNextTaskUnblockTime>
     f7e:	08 95       	ret

00000f80 <prvDeleteTCB>:
     f80:	cf 93       	push	r28
     f82:	df 93       	push	r29
     f84:	ec 01       	movw	r28, r24
     f86:	8f 89       	ldd	r24, Y+23	; 0x17
     f88:	98 8d       	ldd	r25, Y+24	; 0x18
     f8a:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vPortFree>
     f8e:	ce 01       	movw	r24, r28
     f90:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vPortFree>
     f94:	df 91       	pop	r29
     f96:	cf 91       	pop	r28
     f98:	08 95       	ret

00000f9a <prvInitialiseNewTask>:
     f9a:	6f 92       	push	r6
     f9c:	7f 92       	push	r7
     f9e:	8f 92       	push	r8
     fa0:	9f 92       	push	r9
     fa2:	af 92       	push	r10
     fa4:	bf 92       	push	r11
     fa6:	cf 92       	push	r12
     fa8:	df 92       	push	r13
     faa:	ef 92       	push	r14
     fac:	0f 93       	push	r16
     fae:	1f 93       	push	r17
     fb0:	cf 93       	push	r28
     fb2:	df 93       	push	r29
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
     fb8:	4c 01       	movw	r8, r24
     fba:	f5 01       	movw	r30, r10
     fbc:	87 89       	ldd	r24, Z+23	; 0x17
     fbe:	90 8d       	ldd	r25, Z+24	; 0x18
     fc0:	21 50       	subi	r18, 0x01	; 1
     fc2:	31 09       	sbc	r19, r1
     fc4:	3c 01       	movw	r6, r24
     fc6:	62 0e       	add	r6, r18
     fc8:	73 1e       	adc	r7, r19
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	0f c0       	rjmp	.+30     	; 0xfec <prvInitialiseNewTask+0x52>
     fce:	82 2f       	mov	r24, r18
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	fb 01       	movw	r30, r22
     fd4:	e8 0f       	add	r30, r24
     fd6:	f9 1f       	adc	r31, r25
     fd8:	30 81       	ld	r19, Z
     fda:	d5 01       	movw	r26, r10
     fdc:	a8 0f       	add	r26, r24
     fde:	b9 1f       	adc	r27, r25
     fe0:	59 96       	adiw	r26, 0x19	; 25
     fe2:	3c 93       	st	X, r19
     fe4:	80 81       	ld	r24, Z
     fe6:	88 23       	and	r24, r24
     fe8:	19 f0       	breq	.+6      	; 0xff0 <prvInitialiseNewTask+0x56>
     fea:	2f 5f       	subi	r18, 0xFF	; 255
     fec:	28 30       	cpi	r18, 0x08	; 8
     fee:	78 f3       	brcs	.-34     	; 0xfce <prvInitialiseNewTask+0x34>
     ff0:	f5 01       	movw	r30, r10
     ff2:	10 a2       	std	Z+32, r1	; 0x20
     ff4:	f2 e0       	ldi	r31, 0x02	; 2
     ff6:	fe 15       	cp	r31, r14
     ff8:	18 f4       	brcc	.+6      	; 0x1000 <prvInitialiseNewTask+0x66>
     ffa:	68 94       	set
     ffc:	ee 24       	eor	r14, r14
     ffe:	e1 f8       	bld	r14, 1
    1000:	f5 01       	movw	r30, r10
    1002:	e6 8a       	std	Z+22, r14	; 0x16
    1004:	e1 a2       	std	Z+33, r14	; 0x21
    1006:	12 a2       	std	Z+34, r1	; 0x22
    1008:	c5 01       	movw	r24, r10
    100a:	02 96       	adiw	r24, 0x02	; 2
    100c:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialiseItem>
    1010:	c5 01       	movw	r24, r10
    1012:	0c 96       	adiw	r24, 0x0c	; 12
    1014:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialiseItem>
    1018:	f5 01       	movw	r30, r10
    101a:	b1 86       	std	Z+9, r11	; 0x09
    101c:	a0 86       	std	Z+8, r10	; 0x08
    101e:	83 e0       	ldi	r24, 0x03	; 3
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	8e 19       	sub	r24, r14
    1024:	91 09       	sbc	r25, r1
    1026:	95 87       	std	Z+13, r25	; 0x0d
    1028:	84 87       	std	Z+12, r24	; 0x0c
    102a:	b3 8a       	std	Z+19, r11	; 0x13
    102c:	a2 8a       	std	Z+18, r10	; 0x12
    102e:	13 a2       	std	Z+35, r1	; 0x23
    1030:	14 a2       	std	Z+36, r1	; 0x24
    1032:	15 a2       	std	Z+37, r1	; 0x25
    1034:	16 a2       	std	Z+38, r1	; 0x26
    1036:	17 a2       	std	Z+39, r1	; 0x27
    1038:	a8 01       	movw	r20, r16
    103a:	b4 01       	movw	r22, r8
    103c:	c3 01       	movw	r24, r6
    103e:	0e 94 b0 03 	call	0x760	; 0x760 <pxPortInitialiseStack>
    1042:	f5 01       	movw	r30, r10
    1044:	91 83       	std	Z+1, r25	; 0x01
    1046:	80 83       	st	Z, r24
    1048:	c1 14       	cp	r12, r1
    104a:	d1 04       	cpc	r13, r1
    104c:	19 f0       	breq	.+6      	; 0x1054 <prvInitialiseNewTask+0xba>
    104e:	f6 01       	movw	r30, r12
    1050:	b1 82       	std	Z+1, r11	; 0x01
    1052:	a0 82       	st	Z, r10
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	ef 90       	pop	r14
    105e:	df 90       	pop	r13
    1060:	cf 90       	pop	r12
    1062:	bf 90       	pop	r11
    1064:	af 90       	pop	r10
    1066:	9f 90       	pop	r9
    1068:	8f 90       	pop	r8
    106a:	7f 90       	pop	r7
    106c:	6f 90       	pop	r6
    106e:	08 95       	ret

00001070 <prvInitialiseTaskLists>:
    1070:	cf 93       	push	r28
    1072:	c0 e0       	ldi	r28, 0x00	; 0
    1074:	10 c0       	rjmp	.+32     	; 0x1096 <prvInitialiseTaskLists+0x26>
    1076:	8c 2f       	mov	r24, r28
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	9c 01       	movw	r18, r24
    107c:	22 0f       	add	r18, r18
    107e:	33 1f       	adc	r19, r19
    1080:	22 0f       	add	r18, r18
    1082:	33 1f       	adc	r19, r19
    1084:	22 0f       	add	r18, r18
    1086:	33 1f       	adc	r19, r19
    1088:	82 0f       	add	r24, r18
    108a:	93 1f       	adc	r25, r19
    108c:	8f 5c       	subi	r24, 0xCF	; 207
    108e:	9a 4f       	sbci	r25, 0xFA	; 250
    1090:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    1094:	cf 5f       	subi	r28, 0xFF	; 255
    1096:	c3 30       	cpi	r28, 0x03	; 3
    1098:	70 f3       	brcs	.-36     	; 0x1076 <prvInitialiseTaskLists+0x6>
    109a:	88 e2       	ldi	r24, 0x28	; 40
    109c:	95 e0       	ldi	r25, 0x05	; 5
    109e:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    10a2:	8f e1       	ldi	r24, 0x1F	; 31
    10a4:	95 e0       	ldi	r25, 0x05	; 5
    10a6:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    10aa:	82 e1       	ldi	r24, 0x12	; 18
    10ac:	95 e0       	ldi	r25, 0x05	; 5
    10ae:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    10b2:	89 e0       	ldi	r24, 0x09	; 9
    10b4:	95 e0       	ldi	r25, 0x05	; 5
    10b6:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    10ba:	8f ef       	ldi	r24, 0xFF	; 255
    10bc:	94 e0       	ldi	r25, 0x04	; 4
    10be:	0e 94 1d 03 	call	0x63a	; 0x63a <vListInitialise>
    10c2:	88 e2       	ldi	r24, 0x28	; 40
    10c4:	95 e0       	ldi	r25, 0x05	; 5
    10c6:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <pxDelayedTaskList+0x1>
    10ca:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <pxDelayedTaskList>
    10ce:	8f e1       	ldi	r24, 0x1F	; 31
    10d0:	95 e0       	ldi	r25, 0x05	; 5
    10d2:	90 93 1c 05 	sts	0x051C, r25	; 0x80051c <pxOverflowDelayedTaskList+0x1>
    10d6:	80 93 1b 05 	sts	0x051B, r24	; 0x80051b <pxOverflowDelayedTaskList>
    10da:	cf 91       	pop	r28
    10dc:	08 95       	ret

000010de <prvAddNewTaskToReadyList>:
    10de:	cf 93       	push	r28
    10e0:	df 93       	push	r29
    10e2:	ec 01       	movw	r28, r24
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	0f 92       	push	r0
    10ea:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <uxCurrentNumberOfTasks>
    10ee:	8f 5f       	subi	r24, 0xFF	; 255
    10f0:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <uxCurrentNumberOfTasks>
    10f4:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <pxCurrentTCB>
    10f8:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    10fc:	89 2b       	or	r24, r25
    10fe:	59 f4       	brne	.+22     	; 0x1116 <prvAddNewTaskToReadyList+0x38>
    1100:	d0 93 4d 05 	sts	0x054D, r29	; 0x80054d <pxCurrentTCB+0x1>
    1104:	c0 93 4c 05 	sts	0x054C, r28	; 0x80054c <pxCurrentTCB>
    1108:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <uxCurrentNumberOfTasks>
    110c:	81 30       	cpi	r24, 0x01	; 1
    110e:	99 f4       	brne	.+38     	; 0x1136 <prvAddNewTaskToReadyList+0x58>
    1110:	0e 94 38 08 	call	0x1070	; 0x1070 <prvInitialiseTaskLists>
    1114:	10 c0       	rjmp	.+32     	; 0x1136 <prvAddNewTaskToReadyList+0x58>
    1116:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <xSchedulerRunning>
    111a:	81 11       	cpse	r24, r1
    111c:	0c c0       	rjmp	.+24     	; 0x1136 <prvAddNewTaskToReadyList+0x58>
    111e:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1122:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1126:	96 89       	ldd	r25, Z+22	; 0x16
    1128:	8e 89       	ldd	r24, Y+22	; 0x16
    112a:	89 17       	cp	r24, r25
    112c:	20 f0       	brcs	.+8      	; 0x1136 <prvAddNewTaskToReadyList+0x58>
    112e:	d0 93 4d 05 	sts	0x054D, r29	; 0x80054d <pxCurrentTCB+0x1>
    1132:	c0 93 4c 05 	sts	0x054C, r28	; 0x80054c <pxCurrentTCB>
    1136:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <uxTaskNumber>
    113a:	8f 5f       	subi	r24, 0xFF	; 255
    113c:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <uxTaskNumber>
    1140:	8e 89       	ldd	r24, Y+22	; 0x16
    1142:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    1146:	98 17       	cp	r25, r24
    1148:	10 f4       	brcc	.+4      	; 0x114e <prvAddNewTaskToReadyList+0x70>
    114a:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	9c 01       	movw	r18, r24
    1152:	22 0f       	add	r18, r18
    1154:	33 1f       	adc	r19, r19
    1156:	22 0f       	add	r18, r18
    1158:	33 1f       	adc	r19, r19
    115a:	22 0f       	add	r18, r18
    115c:	33 1f       	adc	r19, r19
    115e:	82 0f       	add	r24, r18
    1160:	93 1f       	adc	r25, r19
    1162:	be 01       	movw	r22, r28
    1164:	6e 5f       	subi	r22, 0xFE	; 254
    1166:	7f 4f       	sbci	r23, 0xFF	; 255
    1168:	8f 5c       	subi	r24, 0xCF	; 207
    116a:	9a 4f       	sbci	r25, 0xFA	; 250
    116c:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    1170:	0f 90       	pop	r0
    1172:	0f be       	out	0x3f, r0	; 63
    1174:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <xSchedulerRunning>
    1178:	88 23       	and	r24, r24
    117a:	51 f0       	breq	.+20     	; 0x1190 <prvAddNewTaskToReadyList+0xb2>
    117c:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1180:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1184:	96 89       	ldd	r25, Z+22	; 0x16
    1186:	8e 89       	ldd	r24, Y+22	; 0x16
    1188:	98 17       	cp	r25, r24
    118a:	10 f4       	brcc	.+4      	; 0x1190 <prvAddNewTaskToReadyList+0xb2>
    118c:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	08 95       	ret

00001196 <prvAddCurrentTaskToDelayedList>:
    1196:	ff 92       	push	r15
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	ec 01       	movw	r28, r24
    11a2:	f6 2e       	mov	r15, r22
    11a4:	00 91 fc 04 	lds	r16, 0x04FC	; 0x8004fc <xTickCount>
    11a8:	10 91 fd 04 	lds	r17, 0x04FD	; 0x8004fd <xTickCount+0x1>
    11ac:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <pxCurrentTCB>
    11b0:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    11b4:	02 96       	adiw	r24, 0x02	; 2
    11b6:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    11ba:	cf 3f       	cpi	r28, 0xFF	; 255
    11bc:	8f ef       	ldi	r24, 0xFF	; 255
    11be:	d8 07       	cpc	r29, r24
    11c0:	69 f4       	brne	.+26     	; 0x11dc <prvAddCurrentTaskToDelayedList+0x46>
    11c2:	ff 20       	and	r15, r15
    11c4:	59 f0       	breq	.+22     	; 0x11dc <prvAddCurrentTaskToDelayedList+0x46>
    11c6:	60 91 4c 05 	lds	r22, 0x054C	; 0x80054c <pxCurrentTCB>
    11ca:	70 91 4d 05 	lds	r23, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    11ce:	6e 5f       	subi	r22, 0xFE	; 254
    11d0:	7f 4f       	sbci	r23, 0xFF	; 255
    11d2:	8f ef       	ldi	r24, 0xFF	; 255
    11d4:	94 e0       	ldi	r25, 0x04	; 4
    11d6:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    11da:	2f c0       	rjmp	.+94     	; 0x123a <prvAddCurrentTaskToDelayedList+0xa4>
    11dc:	c0 0f       	add	r28, r16
    11de:	d1 1f       	adc	r29, r17
    11e0:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    11e4:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    11e8:	d3 83       	std	Z+3, r29	; 0x03
    11ea:	c2 83       	std	Z+2, r28	; 0x02
    11ec:	c0 17       	cp	r28, r16
    11ee:	d1 07       	cpc	r29, r17
    11f0:	68 f4       	brcc	.+26     	; 0x120c <prvAddCurrentTaskToDelayedList+0x76>
    11f2:	60 91 4c 05 	lds	r22, 0x054C	; 0x80054c <pxCurrentTCB>
    11f6:	70 91 4d 05 	lds	r23, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    11fa:	80 91 1b 05 	lds	r24, 0x051B	; 0x80051b <pxOverflowDelayedTaskList>
    11fe:	90 91 1c 05 	lds	r25, 0x051C	; 0x80051c <pxOverflowDelayedTaskList+0x1>
    1202:	6e 5f       	subi	r22, 0xFE	; 254
    1204:	7f 4f       	sbci	r23, 0xFF	; 255
    1206:	0e 94 50 03 	call	0x6a0	; 0x6a0 <vListInsert>
    120a:	17 c0       	rjmp	.+46     	; 0x123a <prvAddCurrentTaskToDelayedList+0xa4>
    120c:	60 91 4c 05 	lds	r22, 0x054C	; 0x80054c <pxCurrentTCB>
    1210:	70 91 4d 05 	lds	r23, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1214:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <pxDelayedTaskList>
    1218:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
    121c:	6e 5f       	subi	r22, 0xFE	; 254
    121e:	7f 4f       	sbci	r23, 0xFF	; 255
    1220:	0e 94 50 03 	call	0x6a0	; 0x6a0 <vListInsert>
    1224:	80 91 f4 04 	lds	r24, 0x04F4	; 0x8004f4 <xNextTaskUnblockTime>
    1228:	90 91 f5 04 	lds	r25, 0x04F5	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    122c:	c8 17       	cp	r28, r24
    122e:	d9 07       	cpc	r29, r25
    1230:	20 f4       	brcc	.+8      	; 0x123a <prvAddCurrentTaskToDelayedList+0xa4>
    1232:	d0 93 f5 04 	sts	0x04F5, r29	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    1236:	c0 93 f4 04 	sts	0x04F4, r28	; 0x8004f4 <xNextTaskUnblockTime>
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	1f 91       	pop	r17
    1240:	0f 91       	pop	r16
    1242:	ff 90       	pop	r15
    1244:	08 95       	ret

00001246 <xTaskCreate>:
    1246:	2f 92       	push	r2
    1248:	3f 92       	push	r3
    124a:	4f 92       	push	r4
    124c:	5f 92       	push	r5
    124e:	6f 92       	push	r6
    1250:	7f 92       	push	r7
    1252:	8f 92       	push	r8
    1254:	9f 92       	push	r9
    1256:	af 92       	push	r10
    1258:	bf 92       	push	r11
    125a:	cf 92       	push	r12
    125c:	df 92       	push	r13
    125e:	ef 92       	push	r14
    1260:	ff 92       	push	r15
    1262:	0f 93       	push	r16
    1264:	1f 93       	push	r17
    1266:	cf 93       	push	r28
    1268:	df 93       	push	r29
    126a:	3c 01       	movw	r6, r24
    126c:	1b 01       	movw	r2, r22
    126e:	5a 01       	movw	r10, r20
    1270:	29 01       	movw	r4, r18
    1272:	ca 01       	movw	r24, r20
    1274:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1278:	6c 01       	movw	r12, r24
    127a:	89 2b       	or	r24, r25
    127c:	71 f0       	breq	.+28     	; 0x129a <xTaskCreate+0x54>
    127e:	88 e2       	ldi	r24, 0x28	; 40
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	0e 94 6e 02 	call	0x4dc	; 0x4dc <pvPortMalloc>
    1286:	ec 01       	movw	r28, r24
    1288:	89 2b       	or	r24, r25
    128a:	19 f0       	breq	.+6      	; 0x1292 <xTaskCreate+0x4c>
    128c:	d8 8e       	std	Y+24, r13	; 0x18
    128e:	cf 8a       	std	Y+23, r12	; 0x17
    1290:	06 c0       	rjmp	.+12     	; 0x129e <xTaskCreate+0x58>
    1292:	c6 01       	movw	r24, r12
    1294:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vPortFree>
    1298:	02 c0       	rjmp	.+4      	; 0x129e <xTaskCreate+0x58>
    129a:	c0 e0       	ldi	r28, 0x00	; 0
    129c:	d0 e0       	ldi	r29, 0x00	; 0
    129e:	20 97       	sbiw	r28, 0x00	; 0
    12a0:	91 f0       	breq	.+36     	; 0x12c6 <xTaskCreate+0x80>
    12a2:	95 01       	movw	r18, r10
    12a4:	40 e0       	ldi	r20, 0x00	; 0
    12a6:	50 e0       	ldi	r21, 0x00	; 0
    12a8:	81 2c       	mov	r8, r1
    12aa:	91 2c       	mov	r9, r1
    12ac:	5e 01       	movw	r10, r28
    12ae:	67 01       	movw	r12, r14
    12b0:	e0 2e       	mov	r14, r16
    12b2:	82 01       	movw	r16, r4
    12b4:	b1 01       	movw	r22, r2
    12b6:	c3 01       	movw	r24, r6
    12b8:	0e 94 cd 07 	call	0xf9a	; 0xf9a <prvInitialiseNewTask>
    12bc:	ce 01       	movw	r24, r28
    12be:	0e 94 6f 08 	call	0x10de	; 0x10de <prvAddNewTaskToReadyList>
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	01 c0       	rjmp	.+2      	; 0x12c8 <xTaskCreate+0x82>
    12c6:	8f ef       	ldi	r24, 0xFF	; 255
    12c8:	df 91       	pop	r29
    12ca:	cf 91       	pop	r28
    12cc:	1f 91       	pop	r17
    12ce:	0f 91       	pop	r16
    12d0:	ff 90       	pop	r15
    12d2:	ef 90       	pop	r14
    12d4:	df 90       	pop	r13
    12d6:	cf 90       	pop	r12
    12d8:	bf 90       	pop	r11
    12da:	af 90       	pop	r10
    12dc:	9f 90       	pop	r9
    12de:	8f 90       	pop	r8
    12e0:	7f 90       	pop	r7
    12e2:	6f 90       	pop	r6
    12e4:	5f 90       	pop	r5
    12e6:	4f 90       	pop	r4
    12e8:	3f 90       	pop	r3
    12ea:	2f 90       	pop	r2
    12ec:	08 95       	ret

000012ee <vTaskStartScheduler>:
    12ee:	ef 92       	push	r14
    12f0:	ff 92       	push	r15
    12f2:	0f 93       	push	r16
    12f4:	0f 2e       	mov	r0, r31
    12f6:	f2 ef       	ldi	r31, 0xF2	; 242
    12f8:	ef 2e       	mov	r14, r31
    12fa:	f4 e0       	ldi	r31, 0x04	; 4
    12fc:	ff 2e       	mov	r15, r31
    12fe:	f0 2d       	mov	r31, r0
    1300:	00 e0       	ldi	r16, 0x00	; 0
    1302:	20 e0       	ldi	r18, 0x00	; 0
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	40 e5       	ldi	r20, 0x50	; 80
    1308:	50 e0       	ldi	r21, 0x00	; 0
    130a:	6a ef       	ldi	r22, 0xFA	; 250
    130c:	70 e0       	ldi	r23, 0x00	; 0
    130e:	87 e1       	ldi	r24, 0x17	; 23
    1310:	9b e0       	ldi	r25, 0x0B	; 11
    1312:	0e 94 23 09 	call	0x1246	; 0x1246 <xTaskCreate>
    1316:	81 30       	cpi	r24, 0x01	; 1
    1318:	81 f4       	brne	.+32     	; 0x133a <vTaskStartScheduler+0x4c>
    131a:	f8 94       	cli
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	9f ef       	ldi	r25, 0xFF	; 255
    1320:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    1324:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <xNextTaskUnblockTime>
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xSchedulerRunning>
    132e:	10 92 fd 04 	sts	0x04FD, r1	; 0x8004fd <xTickCount+0x1>
    1332:	10 92 fc 04 	sts	0x04FC, r1	; 0x8004fc <xTickCount>
    1336:	0e 94 1c 04 	call	0x838	; 0x838 <xPortStartScheduler>
    133a:	0f 91       	pop	r16
    133c:	ff 90       	pop	r15
    133e:	ef 90       	pop	r14
    1340:	08 95       	ret

00001342 <vTaskSuspendAll>:
    1342:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    1346:	8f 5f       	subi	r24, 0xFF	; 255
    1348:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <uxSchedulerSuspended>
    134c:	08 95       	ret

0000134e <xTaskIncrementTick>:
    134e:	df 92       	push	r13
    1350:	ef 92       	push	r14
    1352:	ff 92       	push	r15
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    1360:	81 11       	cpse	r24, r1
    1362:	97 c0       	rjmp	.+302    	; 0x1492 <xTaskIncrementTick+0x144>
    1364:	e0 90 fc 04 	lds	r14, 0x04FC	; 0x8004fc <xTickCount>
    1368:	f0 90 fd 04 	lds	r15, 0x04FD	; 0x8004fd <xTickCount+0x1>
    136c:	8f ef       	ldi	r24, 0xFF	; 255
    136e:	e8 1a       	sub	r14, r24
    1370:	f8 0a       	sbc	r15, r24
    1372:	f0 92 fd 04 	sts	0x04FD, r15	; 0x8004fd <xTickCount+0x1>
    1376:	e0 92 fc 04 	sts	0x04FC, r14	; 0x8004fc <xTickCount>
    137a:	e1 14       	cp	r14, r1
    137c:	f1 04       	cpc	r15, r1
    137e:	b9 f4       	brne	.+46     	; 0x13ae <xTaskIncrementTick+0x60>
    1380:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <pxDelayedTaskList>
    1384:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
    1388:	20 91 1b 05 	lds	r18, 0x051B	; 0x80051b <pxOverflowDelayedTaskList>
    138c:	30 91 1c 05 	lds	r19, 0x051C	; 0x80051c <pxOverflowDelayedTaskList+0x1>
    1390:	30 93 1e 05 	sts	0x051E, r19	; 0x80051e <pxDelayedTaskList+0x1>
    1394:	20 93 1d 05 	sts	0x051D, r18	; 0x80051d <pxDelayedTaskList>
    1398:	90 93 1c 05 	sts	0x051C, r25	; 0x80051c <pxOverflowDelayedTaskList+0x1>
    139c:	80 93 1b 05 	sts	0x051B, r24	; 0x80051b <pxOverflowDelayedTaskList>
    13a0:	80 91 f7 04 	lds	r24, 0x04F7	; 0x8004f7 <xNumOfOverflows>
    13a4:	8f 5f       	subi	r24, 0xFF	; 255
    13a6:	80 93 f7 04 	sts	0x04F7, r24	; 0x8004f7 <xNumOfOverflows>
    13aa:	0e 94 a1 07 	call	0xf42	; 0xf42 <prvResetNextTaskUnblockTime>
    13ae:	80 91 f4 04 	lds	r24, 0x04F4	; 0x8004f4 <xNextTaskUnblockTime>
    13b2:	90 91 f5 04 	lds	r25, 0x04F5	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    13b6:	e8 16       	cp	r14, r24
    13b8:	f9 06       	cpc	r15, r25
    13ba:	28 f4       	brcc	.+10     	; 0x13c6 <xTaskIncrementTick+0x78>
    13bc:	d1 2c       	mov	r13, r1
    13be:	53 c0       	rjmp	.+166    	; 0x1466 <xTaskIncrementTick+0x118>
    13c0:	dd 24       	eor	r13, r13
    13c2:	d3 94       	inc	r13
    13c4:	01 c0       	rjmp	.+2      	; 0x13c8 <xTaskIncrementTick+0x7a>
    13c6:	d1 2c       	mov	r13, r1
    13c8:	e0 91 1d 05 	lds	r30, 0x051D	; 0x80051d <pxDelayedTaskList>
    13cc:	f0 91 1e 05 	lds	r31, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
    13d0:	80 81       	ld	r24, Z
    13d2:	81 11       	cpse	r24, r1
    13d4:	07 c0       	rjmp	.+14     	; 0x13e4 <xTaskIncrementTick+0x96>
    13d6:	8f ef       	ldi	r24, 0xFF	; 255
    13d8:	9f ef       	ldi	r25, 0xFF	; 255
    13da:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    13de:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <xNextTaskUnblockTime>
    13e2:	41 c0       	rjmp	.+130    	; 0x1466 <xTaskIncrementTick+0x118>
    13e4:	e0 91 1d 05 	lds	r30, 0x051D	; 0x80051d <pxDelayedTaskList>
    13e8:	f0 91 1e 05 	lds	r31, 0x051E	; 0x80051e <pxDelayedTaskList+0x1>
    13ec:	05 80       	ldd	r0, Z+5	; 0x05
    13ee:	f6 81       	ldd	r31, Z+6	; 0x06
    13f0:	e0 2d       	mov	r30, r0
    13f2:	c6 81       	ldd	r28, Z+6	; 0x06
    13f4:	d7 81       	ldd	r29, Z+7	; 0x07
    13f6:	8a 81       	ldd	r24, Y+2	; 0x02
    13f8:	9b 81       	ldd	r25, Y+3	; 0x03
    13fa:	e8 16       	cp	r14, r24
    13fc:	f9 06       	cpc	r15, r25
    13fe:	28 f4       	brcc	.+10     	; 0x140a <xTaskIncrementTick+0xbc>
    1400:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <xNextTaskUnblockTime+0x1>
    1404:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <xNextTaskUnblockTime>
    1408:	2e c0       	rjmp	.+92     	; 0x1466 <xTaskIncrementTick+0x118>
    140a:	8e 01       	movw	r16, r28
    140c:	0e 5f       	subi	r16, 0xFE	; 254
    140e:	1f 4f       	sbci	r17, 0xFF	; 255
    1410:	c8 01       	movw	r24, r16
    1412:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1416:	8c 89       	ldd	r24, Y+20	; 0x14
    1418:	9d 89       	ldd	r25, Y+21	; 0x15
    141a:	89 2b       	or	r24, r25
    141c:	21 f0       	breq	.+8      	; 0x1426 <xTaskIncrementTick+0xd8>
    141e:	ce 01       	movw	r24, r28
    1420:	0c 96       	adiw	r24, 0x0c	; 12
    1422:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1426:	8e 89       	ldd	r24, Y+22	; 0x16
    1428:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    142c:	98 17       	cp	r25, r24
    142e:	10 f4       	brcc	.+4      	; 0x1434 <xTaskIncrementTick+0xe6>
    1430:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	9c 01       	movw	r18, r24
    1438:	22 0f       	add	r18, r18
    143a:	33 1f       	adc	r19, r19
    143c:	22 0f       	add	r18, r18
    143e:	33 1f       	adc	r19, r19
    1440:	22 0f       	add	r18, r18
    1442:	33 1f       	adc	r19, r19
    1444:	82 0f       	add	r24, r18
    1446:	93 1f       	adc	r25, r19
    1448:	b8 01       	movw	r22, r16
    144a:	8f 5c       	subi	r24, 0xCF	; 207
    144c:	9a 4f       	sbci	r25, 0xFA	; 250
    144e:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    1452:	9e 89       	ldd	r25, Y+22	; 0x16
    1454:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1458:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    145c:	86 89       	ldd	r24, Z+22	; 0x16
    145e:	98 17       	cp	r25, r24
    1460:	08 f0       	brcs	.+2      	; 0x1464 <xTaskIncrementTick+0x116>
    1462:	ae cf       	rjmp	.-164    	; 0x13c0 <xTaskIncrementTick+0x72>
    1464:	b1 cf       	rjmp	.-158    	; 0x13c8 <xTaskIncrementTick+0x7a>
    1466:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    146a:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    146e:	86 89       	ldd	r24, Z+22	; 0x16
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	fc 01       	movw	r30, r24
    1474:	ee 0f       	add	r30, r30
    1476:	ff 1f       	adc	r31, r31
    1478:	ee 0f       	add	r30, r30
    147a:	ff 1f       	adc	r31, r31
    147c:	ee 0f       	add	r30, r30
    147e:	ff 1f       	adc	r31, r31
    1480:	8e 0f       	add	r24, r30
    1482:	9f 1f       	adc	r25, r31
    1484:	fc 01       	movw	r30, r24
    1486:	ef 5c       	subi	r30, 0xCF	; 207
    1488:	fa 4f       	sbci	r31, 0xFA	; 250
    148a:	80 81       	ld	r24, Z
    148c:	82 30       	cpi	r24, 0x02	; 2
    148e:	40 f4       	brcc	.+16     	; 0x14a0 <xTaskIncrementTick+0x152>
    1490:	09 c0       	rjmp	.+18     	; 0x14a4 <xTaskIncrementTick+0x156>
    1492:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <uxPendedTicks>
    1496:	8f 5f       	subi	r24, 0xFF	; 255
    1498:	80 93 f9 04 	sts	0x04F9, r24	; 0x8004f9 <uxPendedTicks>
    149c:	d1 2c       	mov	r13, r1
    149e:	02 c0       	rjmp	.+4      	; 0x14a4 <xTaskIncrementTick+0x156>
    14a0:	dd 24       	eor	r13, r13
    14a2:	d3 94       	inc	r13
    14a4:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <xYieldPending>
    14a8:	88 23       	and	r24, r24
    14aa:	11 f0       	breq	.+4      	; 0x14b0 <xTaskIncrementTick+0x162>
    14ac:	dd 24       	eor	r13, r13
    14ae:	d3 94       	inc	r13
    14b0:	8d 2d       	mov	r24, r13
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	ff 90       	pop	r15
    14bc:	ef 90       	pop	r14
    14be:	df 90       	pop	r13
    14c0:	08 95       	ret

000014c2 <xTaskResumeAll>:
    14c2:	0f 93       	push	r16
    14c4:	1f 93       	push	r17
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	0f 92       	push	r0
    14d0:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    14d4:	81 50       	subi	r24, 0x01	; 1
    14d6:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <uxSchedulerSuspended>
    14da:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    14de:	81 11       	cpse	r24, r1
    14e0:	58 c0       	rjmp	.+176    	; 0x1592 <xTaskResumeAll+0xd0>
    14e2:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <uxCurrentNumberOfTasks>
    14e6:	81 11       	cpse	r24, r1
    14e8:	33 c0       	rjmp	.+102    	; 0x1550 <xTaskResumeAll+0x8e>
    14ea:	56 c0       	rjmp	.+172    	; 0x1598 <xTaskResumeAll+0xd6>
    14ec:	e0 91 17 05 	lds	r30, 0x0517	; 0x800517 <xPendingReadyList+0x5>
    14f0:	f0 91 18 05 	lds	r31, 0x0518	; 0x800518 <xPendingReadyList+0x6>
    14f4:	c6 81       	ldd	r28, Z+6	; 0x06
    14f6:	d7 81       	ldd	r29, Z+7	; 0x07
    14f8:	ce 01       	movw	r24, r28
    14fa:	0c 96       	adiw	r24, 0x0c	; 12
    14fc:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1500:	8e 01       	movw	r16, r28
    1502:	0e 5f       	subi	r16, 0xFE	; 254
    1504:	1f 4f       	sbci	r17, 0xFF	; 255
    1506:	c8 01       	movw	r24, r16
    1508:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    150c:	8e 89       	ldd	r24, Y+22	; 0x16
    150e:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    1512:	98 17       	cp	r25, r24
    1514:	10 f4       	brcc	.+4      	; 0x151a <xTaskResumeAll+0x58>
    1516:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    151a:	90 e0       	ldi	r25, 0x00	; 0
    151c:	9c 01       	movw	r18, r24
    151e:	22 0f       	add	r18, r18
    1520:	33 1f       	adc	r19, r19
    1522:	22 0f       	add	r18, r18
    1524:	33 1f       	adc	r19, r19
    1526:	22 0f       	add	r18, r18
    1528:	33 1f       	adc	r19, r19
    152a:	82 0f       	add	r24, r18
    152c:	93 1f       	adc	r25, r19
    152e:	b8 01       	movw	r22, r16
    1530:	8f 5c       	subi	r24, 0xCF	; 207
    1532:	9a 4f       	sbci	r25, 0xFA	; 250
    1534:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    1538:	9e 89       	ldd	r25, Y+22	; 0x16
    153a:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    153e:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1542:	86 89       	ldd	r24, Z+22	; 0x16
    1544:	98 17       	cp	r25, r24
    1546:	30 f0       	brcs	.+12     	; 0x1554 <xTaskResumeAll+0x92>
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <xYieldPending>
    154e:	02 c0       	rjmp	.+4      	; 0x1554 <xTaskResumeAll+0x92>
    1550:	c0 e0       	ldi	r28, 0x00	; 0
    1552:	d0 e0       	ldi	r29, 0x00	; 0
    1554:	80 91 12 05 	lds	r24, 0x0512	; 0x800512 <xPendingReadyList>
    1558:	81 11       	cpse	r24, r1
    155a:	c8 cf       	rjmp	.-112    	; 0x14ec <xTaskResumeAll+0x2a>
    155c:	cd 2b       	or	r28, r29
    155e:	11 f0       	breq	.+4      	; 0x1564 <xTaskResumeAll+0xa2>
    1560:	0e 94 a1 07 	call	0xf42	; 0xf42 <prvResetNextTaskUnblockTime>
    1564:	c0 91 f9 04 	lds	r28, 0x04F9	; 0x8004f9 <uxPendedTicks>
    1568:	cc 23       	and	r28, r28
    156a:	59 f0       	breq	.+22     	; 0x1582 <xTaskResumeAll+0xc0>
    156c:	0e 94 a7 09 	call	0x134e	; 0x134e <xTaskIncrementTick>
    1570:	88 23       	and	r24, r24
    1572:	19 f0       	breq	.+6      	; 0x157a <xTaskResumeAll+0xb8>
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <xYieldPending>
    157a:	c1 50       	subi	r28, 0x01	; 1
    157c:	b9 f7       	brne	.-18     	; 0x156c <xTaskResumeAll+0xaa>
    157e:	10 92 f9 04 	sts	0x04F9, r1	; 0x8004f9 <uxPendedTicks>
    1582:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <xYieldPending>
    1586:	88 23       	and	r24, r24
    1588:	31 f0       	breq	.+12     	; 0x1596 <xTaskResumeAll+0xd4>
    158a:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	03 c0       	rjmp	.+6      	; 0x1598 <xTaskResumeAll+0xd6>
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <xTaskResumeAll+0xd6>
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	0f 90       	pop	r0
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	df 91       	pop	r29
    159e:	cf 91       	pop	r28
    15a0:	1f 91       	pop	r17
    15a2:	0f 91       	pop	r16
    15a4:	08 95       	ret

000015a6 <vTaskDelay>:
    15a6:	cf 93       	push	r28
    15a8:	df 93       	push	r29
    15aa:	ec 01       	movw	r28, r24
    15ac:	89 2b       	or	r24, r25
    15ae:	49 f0       	breq	.+18     	; 0x15c2 <vTaskDelay+0x1c>
    15b0:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
    15b4:	60 e0       	ldi	r22, 0x00	; 0
    15b6:	ce 01       	movw	r24, r28
    15b8:	0e 94 cb 08 	call	0x1196	; 0x1196 <prvAddCurrentTaskToDelayedList>
    15bc:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
    15c0:	01 c0       	rjmp	.+2      	; 0x15c4 <vTaskDelay+0x1e>
    15c2:	80 e0       	ldi	r24, 0x00	; 0
    15c4:	81 11       	cpse	r24, r1
    15c6:	02 c0       	rjmp	.+4      	; 0x15cc <vTaskDelay+0x26>
    15c8:	0e 94 4b 04 	call	0x896	; 0x896 <vPortYield>
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	08 95       	ret

000015d2 <prvCheckTasksWaitingTermination>:
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	24 c0       	rjmp	.+72     	; 0x1620 <prvCheckTasksWaitingTermination+0x4e>
    15d8:	0e 94 a1 09 	call	0x1342	; 0x1342 <vTaskSuspendAll>
    15dc:	c0 91 09 05 	lds	r28, 0x0509	; 0x800509 <xTasksWaitingTermination>
    15e0:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <xTaskResumeAll>
    15e4:	cc 23       	and	r28, r28
    15e6:	e1 f0       	breq	.+56     	; 0x1620 <prvCheckTasksWaitingTermination+0x4e>
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	0f 92       	push	r0
    15ee:	e0 91 0e 05 	lds	r30, 0x050E	; 0x80050e <xTasksWaitingTermination+0x5>
    15f2:	f0 91 0f 05 	lds	r31, 0x050F	; 0x80050f <xTasksWaitingTermination+0x6>
    15f6:	c6 81       	ldd	r28, Z+6	; 0x06
    15f8:	d7 81       	ldd	r29, Z+7	; 0x07
    15fa:	ce 01       	movw	r24, r28
    15fc:	02 96       	adiw	r24, 0x02	; 2
    15fe:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1602:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <uxCurrentNumberOfTasks>
    1606:	81 50       	subi	r24, 0x01	; 1
    1608:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <uxCurrentNumberOfTasks>
    160c:	80 91 08 05 	lds	r24, 0x0508	; 0x800508 <uxDeletedTasksWaitingCleanUp>
    1610:	81 50       	subi	r24, 0x01	; 1
    1612:	80 93 08 05 	sts	0x0508, r24	; 0x800508 <uxDeletedTasksWaitingCleanUp>
    1616:	0f 90       	pop	r0
    1618:	0f be       	out	0x3f, r0	; 63
    161a:	ce 01       	movw	r24, r28
    161c:	0e 94 c0 07 	call	0xf80	; 0xf80 <prvDeleteTCB>
    1620:	80 91 08 05 	lds	r24, 0x0508	; 0x800508 <uxDeletedTasksWaitingCleanUp>
    1624:	81 11       	cpse	r24, r1
    1626:	d8 cf       	rjmp	.-80     	; 0x15d8 <prvCheckTasksWaitingTermination+0x6>
    1628:	df 91       	pop	r29
    162a:	cf 91       	pop	r28
    162c:	08 95       	ret

0000162e <prvIdleTask>:
    162e:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <prvCheckTasksWaitingTermination>
    1632:	fd cf       	rjmp	.-6      	; 0x162e <prvIdleTask>

00001634 <vTaskSwitchContext>:
    1634:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    1638:	88 23       	and	r24, r24
    163a:	21 f0       	breq	.+8      	; 0x1644 <vTaskSwitchContext+0x10>
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <xYieldPending>
    1642:	08 95       	ret
    1644:	10 92 f8 04 	sts	0x04F8, r1	; 0x8004f8 <xYieldPending>
    1648:	20 91 fb 04 	lds	r18, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    164c:	01 c0       	rjmp	.+2      	; 0x1650 <vTaskSwitchContext+0x1c>
    164e:	21 50       	subi	r18, 0x01	; 1
    1650:	82 2f       	mov	r24, r18
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	fc 01       	movw	r30, r24
    1656:	ee 0f       	add	r30, r30
    1658:	ff 1f       	adc	r31, r31
    165a:	ee 0f       	add	r30, r30
    165c:	ff 1f       	adc	r31, r31
    165e:	ee 0f       	add	r30, r30
    1660:	ff 1f       	adc	r31, r31
    1662:	e8 0f       	add	r30, r24
    1664:	f9 1f       	adc	r31, r25
    1666:	ef 5c       	subi	r30, 0xCF	; 207
    1668:	fa 4f       	sbci	r31, 0xFA	; 250
    166a:	30 81       	ld	r19, Z
    166c:	33 23       	and	r19, r19
    166e:	79 f3       	breq	.-34     	; 0x164e <vTaskSwitchContext+0x1a>
    1670:	ac 01       	movw	r20, r24
    1672:	44 0f       	add	r20, r20
    1674:	55 1f       	adc	r21, r21
    1676:	44 0f       	add	r20, r20
    1678:	55 1f       	adc	r21, r21
    167a:	44 0f       	add	r20, r20
    167c:	55 1f       	adc	r21, r21
    167e:	48 0f       	add	r20, r24
    1680:	59 1f       	adc	r21, r25
    1682:	df 01       	movw	r26, r30
    1684:	01 80       	ldd	r0, Z+1	; 0x01
    1686:	f2 81       	ldd	r31, Z+2	; 0x02
    1688:	e0 2d       	mov	r30, r0
    168a:	02 80       	ldd	r0, Z+2	; 0x02
    168c:	f3 81       	ldd	r31, Z+3	; 0x03
    168e:	e0 2d       	mov	r30, r0
    1690:	12 96       	adiw	r26, 0x02	; 2
    1692:	fc 93       	st	X, r31
    1694:	ee 93       	st	-X, r30
    1696:	11 97       	sbiw	r26, 0x01	; 1
    1698:	4c 5c       	subi	r20, 0xCC	; 204
    169a:	5a 4f       	sbci	r21, 0xFA	; 250
    169c:	e4 17       	cp	r30, r20
    169e:	f5 07       	cpc	r31, r21
    16a0:	29 f4       	brne	.+10     	; 0x16ac <vTaskSwitchContext+0x78>
    16a2:	42 81       	ldd	r20, Z+2	; 0x02
    16a4:	53 81       	ldd	r21, Z+3	; 0x03
    16a6:	fd 01       	movw	r30, r26
    16a8:	52 83       	std	Z+2, r21	; 0x02
    16aa:	41 83       	std	Z+1, r20	; 0x01
    16ac:	fc 01       	movw	r30, r24
    16ae:	ee 0f       	add	r30, r30
    16b0:	ff 1f       	adc	r31, r31
    16b2:	ee 0f       	add	r30, r30
    16b4:	ff 1f       	adc	r31, r31
    16b6:	ee 0f       	add	r30, r30
    16b8:	ff 1f       	adc	r31, r31
    16ba:	8e 0f       	add	r24, r30
    16bc:	9f 1f       	adc	r25, r31
    16be:	fc 01       	movw	r30, r24
    16c0:	ef 5c       	subi	r30, 0xCF	; 207
    16c2:	fa 4f       	sbci	r31, 0xFA	; 250
    16c4:	01 80       	ldd	r0, Z+1	; 0x01
    16c6:	f2 81       	ldd	r31, Z+2	; 0x02
    16c8:	e0 2d       	mov	r30, r0
    16ca:	86 81       	ldd	r24, Z+6	; 0x06
    16cc:	97 81       	ldd	r25, Z+7	; 0x07
    16ce:	90 93 4d 05 	sts	0x054D, r25	; 0x80054d <pxCurrentTCB+0x1>
    16d2:	80 93 4c 05 	sts	0x054C, r24	; 0x80054c <pxCurrentTCB>
    16d6:	20 93 fb 04 	sts	0x04FB, r18	; 0x8004fb <uxTopReadyPriority>
    16da:	08 95       	ret

000016dc <vTaskPlaceOnEventList>:
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	eb 01       	movw	r28, r22
    16e2:	60 91 4c 05 	lds	r22, 0x054C	; 0x80054c <pxCurrentTCB>
    16e6:	70 91 4d 05 	lds	r23, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    16ea:	64 5f       	subi	r22, 0xF4	; 244
    16ec:	7f 4f       	sbci	r23, 0xFF	; 255
    16ee:	0e 94 50 03 	call	0x6a0	; 0x6a0 <vListInsert>
    16f2:	61 e0       	ldi	r22, 0x01	; 1
    16f4:	ce 01       	movw	r24, r28
    16f6:	0e 94 cb 08 	call	0x1196	; 0x1196 <prvAddCurrentTaskToDelayedList>
    16fa:	df 91       	pop	r29
    16fc:	cf 91       	pop	r28
    16fe:	08 95       	ret

00001700 <xTaskRemoveFromEventList>:
    1700:	0f 93       	push	r16
    1702:	1f 93       	push	r17
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	dc 01       	movw	r26, r24
    170a:	15 96       	adiw	r26, 0x05	; 5
    170c:	ed 91       	ld	r30, X+
    170e:	fc 91       	ld	r31, X
    1710:	16 97       	sbiw	r26, 0x06	; 6
    1712:	c6 81       	ldd	r28, Z+6	; 0x06
    1714:	d7 81       	ldd	r29, Z+7	; 0x07
    1716:	8e 01       	movw	r16, r28
    1718:	04 5f       	subi	r16, 0xF4	; 244
    171a:	1f 4f       	sbci	r17, 0xFF	; 255
    171c:	c8 01       	movw	r24, r16
    171e:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1722:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <uxSchedulerSuspended>
    1726:	81 11       	cpse	r24, r1
    1728:	1c c0       	rjmp	.+56     	; 0x1762 <xTaskRemoveFromEventList+0x62>
    172a:	0a 50       	subi	r16, 0x0A	; 10
    172c:	11 09       	sbc	r17, r1
    172e:	c8 01       	movw	r24, r16
    1730:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1734:	8e 89       	ldd	r24, Y+22	; 0x16
    1736:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    173a:	98 17       	cp	r25, r24
    173c:	10 f4       	brcc	.+4      	; 0x1742 <xTaskRemoveFromEventList+0x42>
    173e:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	9c 01       	movw	r18, r24
    1746:	22 0f       	add	r18, r18
    1748:	33 1f       	adc	r19, r19
    174a:	22 0f       	add	r18, r18
    174c:	33 1f       	adc	r19, r19
    174e:	22 0f       	add	r18, r18
    1750:	33 1f       	adc	r19, r19
    1752:	82 0f       	add	r24, r18
    1754:	93 1f       	adc	r25, r19
    1756:	b8 01       	movw	r22, r16
    1758:	8f 5c       	subi	r24, 0xCF	; 207
    175a:	9a 4f       	sbci	r25, 0xFA	; 250
    175c:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    1760:	05 c0       	rjmp	.+10     	; 0x176c <xTaskRemoveFromEventList+0x6c>
    1762:	b8 01       	movw	r22, r16
    1764:	82 e1       	ldi	r24, 0x12	; 18
    1766:	95 e0       	ldi	r25, 0x05	; 5
    1768:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    176c:	9e 89       	ldd	r25, Y+22	; 0x16
    176e:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1772:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1776:	86 89       	ldd	r24, Z+22	; 0x16
    1778:	89 17       	cp	r24, r25
    177a:	20 f4       	brcc	.+8      	; 0x1784 <xTaskRemoveFromEventList+0x84>
    177c:	81 e0       	ldi	r24, 0x01	; 1
    177e:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <xYieldPending>
    1782:	01 c0       	rjmp	.+2      	; 0x1786 <xTaskRemoveFromEventList+0x86>
    1784:	80 e0       	ldi	r24, 0x00	; 0
    1786:	df 91       	pop	r29
    1788:	cf 91       	pop	r28
    178a:	1f 91       	pop	r17
    178c:	0f 91       	pop	r16
    178e:	08 95       	ret

00001790 <vTaskSetTimeOutState>:
    1790:	20 91 f7 04 	lds	r18, 0x04F7	; 0x8004f7 <xNumOfOverflows>
    1794:	fc 01       	movw	r30, r24
    1796:	20 83       	st	Z, r18
    1798:	20 91 fc 04 	lds	r18, 0x04FC	; 0x8004fc <xTickCount>
    179c:	30 91 fd 04 	lds	r19, 0x04FD	; 0x8004fd <xTickCount+0x1>
    17a0:	32 83       	std	Z+2, r19	; 0x02
    17a2:	21 83       	std	Z+1, r18	; 0x01
    17a4:	08 95       	ret

000017a6 <xTaskCheckForTimeOut>:
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	f8 94       	cli
    17aa:	0f 92       	push	r0
    17ac:	40 91 fc 04 	lds	r20, 0x04FC	; 0x8004fc <xTickCount>
    17b0:	50 91 fd 04 	lds	r21, 0x04FD	; 0x8004fd <xTickCount+0x1>
    17b4:	db 01       	movw	r26, r22
    17b6:	2d 91       	ld	r18, X+
    17b8:	3c 91       	ld	r19, X
    17ba:	2f 3f       	cpi	r18, 0xFF	; 255
    17bc:	bf ef       	ldi	r27, 0xFF	; 255
    17be:	3b 07       	cpc	r19, r27
    17c0:	19 f1       	breq	.+70     	; 0x1808 <xTaskCheckForTimeOut+0x62>
    17c2:	dc 01       	movw	r26, r24
    17c4:	fc 91       	ld	r31, X
    17c6:	e0 91 f7 04 	lds	r30, 0x04F7	; 0x8004f7 <xNumOfOverflows>
    17ca:	fe 17       	cp	r31, r30
    17cc:	39 f0       	breq	.+14     	; 0x17dc <xTaskCheckForTimeOut+0x36>
    17ce:	11 96       	adiw	r26, 0x01	; 1
    17d0:	ed 91       	ld	r30, X+
    17d2:	fc 91       	ld	r31, X
    17d4:	12 97       	sbiw	r26, 0x02	; 2
    17d6:	4e 17       	cp	r20, r30
    17d8:	5f 07       	cpc	r21, r31
    17da:	c0 f4       	brcc	.+48     	; 0x180c <xTaskCheckForTimeOut+0x66>
    17dc:	dc 01       	movw	r26, r24
    17de:	11 96       	adiw	r26, 0x01	; 1
    17e0:	ed 91       	ld	r30, X+
    17e2:	fc 91       	ld	r31, X
    17e4:	12 97       	sbiw	r26, 0x02	; 2
    17e6:	da 01       	movw	r26, r20
    17e8:	ae 1b       	sub	r26, r30
    17ea:	bf 0b       	sbc	r27, r31
    17ec:	a2 17       	cp	r26, r18
    17ee:	b3 07       	cpc	r27, r19
    17f0:	78 f4       	brcc	.+30     	; 0x1810 <xTaskCheckForTimeOut+0x6a>
    17f2:	db 01       	movw	r26, r22
    17f4:	e4 1b       	sub	r30, r20
    17f6:	f5 0b       	sbc	r31, r21
    17f8:	2e 0f       	add	r18, r30
    17fa:	3f 1f       	adc	r19, r31
    17fc:	2d 93       	st	X+, r18
    17fe:	3c 93       	st	X, r19
    1800:	0e 94 c8 0b 	call	0x1790	; 0x1790 <vTaskSetTimeOutState>
    1804:	80 e0       	ldi	r24, 0x00	; 0
    1806:	05 c0       	rjmp	.+10     	; 0x1812 <xTaskCheckForTimeOut+0x6c>
    1808:	80 e0       	ldi	r24, 0x00	; 0
    180a:	03 c0       	rjmp	.+6      	; 0x1812 <xTaskCheckForTimeOut+0x6c>
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	01 c0       	rjmp	.+2      	; 0x1812 <xTaskCheckForTimeOut+0x6c>
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	0f 90       	pop	r0
    1814:	0f be       	out	0x3f, r0	; 63
    1816:	08 95       	ret

00001818 <vTaskMissedYield>:
    1818:	81 e0       	ldi	r24, 0x01	; 1
    181a:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <xYieldPending>
    181e:	08 95       	ret

00001820 <vTaskPriorityInherit>:
    1820:	0f 93       	push	r16
    1822:	1f 93       	push	r17
    1824:	cf 93       	push	r28
    1826:	df 93       	push	r29
    1828:	fc 01       	movw	r30, r24
    182a:	89 2b       	or	r24, r25
    182c:	09 f4       	brne	.+2      	; 0x1830 <vTaskPriorityInherit+0x10>
    182e:	55 c0       	rjmp	.+170    	; 0x18da <vTaskPriorityInherit+0xba>
    1830:	26 89       	ldd	r18, Z+22	; 0x16
    1832:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
    1836:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    183a:	56 96       	adiw	r26, 0x16	; 22
    183c:	8c 91       	ld	r24, X
    183e:	28 17       	cp	r18, r24
    1840:	08 f0       	brcs	.+2      	; 0x1844 <vTaskPriorityInherit+0x24>
    1842:	4b c0       	rjmp	.+150    	; 0x18da <vTaskPriorityInherit+0xba>
    1844:	84 85       	ldd	r24, Z+12	; 0x0c
    1846:	95 85       	ldd	r25, Z+13	; 0x0d
    1848:	99 23       	and	r25, r25
    184a:	64 f0       	brlt	.+24     	; 0x1864 <vTaskPriorityInherit+0x44>
    184c:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
    1850:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1854:	56 96       	adiw	r26, 0x16	; 22
    1856:	3c 91       	ld	r19, X
    1858:	83 e0       	ldi	r24, 0x03	; 3
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	83 1b       	sub	r24, r19
    185e:	91 09       	sbc	r25, r1
    1860:	95 87       	std	Z+13, r25	; 0x0d
    1862:	84 87       	std	Z+12, r24	; 0x0c
    1864:	82 85       	ldd	r24, Z+10	; 0x0a
    1866:	93 85       	ldd	r25, Z+11	; 0x0b
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	a9 01       	movw	r20, r18
    186c:	44 0f       	add	r20, r20
    186e:	55 1f       	adc	r21, r21
    1870:	44 0f       	add	r20, r20
    1872:	55 1f       	adc	r21, r21
    1874:	44 0f       	add	r20, r20
    1876:	55 1f       	adc	r21, r21
    1878:	24 0f       	add	r18, r20
    187a:	35 1f       	adc	r19, r21
    187c:	2f 5c       	subi	r18, 0xCF	; 207
    187e:	3a 4f       	sbci	r19, 0xFA	; 250
    1880:	82 17       	cp	r24, r18
    1882:	93 07       	cpc	r25, r19
    1884:	19 f5       	brne	.+70     	; 0x18cc <vTaskPriorityInherit+0xac>
    1886:	8f 01       	movw	r16, r30
    1888:	ef 01       	movw	r28, r30
    188a:	22 96       	adiw	r28, 0x02	; 2
    188c:	ce 01       	movw	r24, r28
    188e:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1892:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1896:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    189a:	86 89       	ldd	r24, Z+22	; 0x16
    189c:	f8 01       	movw	r30, r16
    189e:	86 8b       	std	Z+22, r24	; 0x16
    18a0:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    18a4:	98 17       	cp	r25, r24
    18a6:	10 f4       	brcc	.+4      	; 0x18ac <vTaskPriorityInherit+0x8c>
    18a8:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	9c 01       	movw	r18, r24
    18b0:	22 0f       	add	r18, r18
    18b2:	33 1f       	adc	r19, r19
    18b4:	22 0f       	add	r18, r18
    18b6:	33 1f       	adc	r19, r19
    18b8:	22 0f       	add	r18, r18
    18ba:	33 1f       	adc	r19, r19
    18bc:	82 0f       	add	r24, r18
    18be:	93 1f       	adc	r25, r19
    18c0:	be 01       	movw	r22, r28
    18c2:	8f 5c       	subi	r24, 0xCF	; 207
    18c4:	9a 4f       	sbci	r25, 0xFA	; 250
    18c6:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    18ca:	07 c0       	rjmp	.+14     	; 0x18da <vTaskPriorityInherit+0xba>
    18cc:	a0 91 4c 05 	lds	r26, 0x054C	; 0x80054c <pxCurrentTCB>
    18d0:	b0 91 4d 05 	lds	r27, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    18d4:	56 96       	adiw	r26, 0x16	; 22
    18d6:	8c 91       	ld	r24, X
    18d8:	86 8b       	std	Z+22, r24	; 0x16
    18da:	df 91       	pop	r29
    18dc:	cf 91       	pop	r28
    18de:	1f 91       	pop	r17
    18e0:	0f 91       	pop	r16
    18e2:	08 95       	ret

000018e4 <xTaskPriorityDisinherit>:
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	cf 93       	push	r28
    18ea:	df 93       	push	r29
    18ec:	fc 01       	movw	r30, r24
    18ee:	89 2b       	or	r24, r25
    18f0:	79 f1       	breq	.+94     	; 0x1950 <xTaskPriorityDisinherit+0x6c>
    18f2:	82 a1       	ldd	r24, Z+34	; 0x22
    18f4:	81 50       	subi	r24, 0x01	; 1
    18f6:	82 a3       	std	Z+34, r24	; 0x22
    18f8:	26 89       	ldd	r18, Z+22	; 0x16
    18fa:	91 a1       	ldd	r25, Z+33	; 0x21
    18fc:	29 17       	cp	r18, r25
    18fe:	51 f1       	breq	.+84     	; 0x1954 <xTaskPriorityDisinherit+0x70>
    1900:	81 11       	cpse	r24, r1
    1902:	2a c0       	rjmp	.+84     	; 0x1958 <xTaskPriorityDisinherit+0x74>
    1904:	ef 01       	movw	r28, r30
    1906:	8f 01       	movw	r16, r30
    1908:	0e 5f       	subi	r16, 0xFE	; 254
    190a:	1f 4f       	sbci	r17, 0xFF	; 255
    190c:	c8 01       	movw	r24, r16
    190e:	0e 94 81 03 	call	0x702	; 0x702 <uxListRemove>
    1912:	89 a1       	ldd	r24, Y+33	; 0x21
    1914:	8e 8b       	std	Y+22, r24	; 0x16
    1916:	23 e0       	ldi	r18, 0x03	; 3
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	28 1b       	sub	r18, r24
    191c:	31 09       	sbc	r19, r1
    191e:	3d 87       	std	Y+13, r19	; 0x0d
    1920:	2c 87       	std	Y+12, r18	; 0x0c
    1922:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <uxTopReadyPriority>
    1926:	98 17       	cp	r25, r24
    1928:	10 f4       	brcc	.+4      	; 0x192e <xTaskPriorityDisinherit+0x4a>
    192a:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxTopReadyPriority>
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	9c 01       	movw	r18, r24
    1932:	22 0f       	add	r18, r18
    1934:	33 1f       	adc	r19, r19
    1936:	22 0f       	add	r18, r18
    1938:	33 1f       	adc	r19, r19
    193a:	22 0f       	add	r18, r18
    193c:	33 1f       	adc	r19, r19
    193e:	82 0f       	add	r24, r18
    1940:	93 1f       	adc	r25, r19
    1942:	b8 01       	movw	r22, r16
    1944:	8f 5c       	subi	r24, 0xCF	; 207
    1946:	9a 4f       	sbci	r25, 0xFA	; 250
    1948:	0e 94 2f 03 	call	0x65e	; 0x65e <vListInsertEnd>
    194c:	81 e0       	ldi	r24, 0x01	; 1
    194e:	05 c0       	rjmp	.+10     	; 0x195a <xTaskPriorityDisinherit+0x76>
    1950:	80 e0       	ldi	r24, 0x00	; 0
    1952:	03 c0       	rjmp	.+6      	; 0x195a <xTaskPriorityDisinherit+0x76>
    1954:	80 e0       	ldi	r24, 0x00	; 0
    1956:	01 c0       	rjmp	.+2      	; 0x195a <xTaskPriorityDisinherit+0x76>
    1958:	80 e0       	ldi	r24, 0x00	; 0
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	1f 91       	pop	r17
    1960:	0f 91       	pop	r16
    1962:	08 95       	ret

00001964 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1964:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <pxCurrentTCB>
    1968:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    196c:	89 2b       	or	r24, r25
    196e:	39 f0       	breq	.+14     	; 0x197e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1970:	e0 91 4c 05 	lds	r30, 0x054C	; 0x80054c <pxCurrentTCB>
    1974:	f0 91 4d 05 	lds	r31, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
    1978:	82 a1       	ldd	r24, Z+34	; 0x22
    197a:	8f 5f       	subi	r24, 0xFF	; 255
    197c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    197e:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <pxCurrentTCB>
    1982:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <pxCurrentTCB+0x1>
	}
    1986:	08 95       	ret

00001988 <LCD_voidSHD>:
	  LCD_voidSendData(pattern) ; 
	  
	  
	
	
}
    1988:	0f 93       	push	r16
    198a:	1f 93       	push	r17
    198c:	cf 93       	push	r28
    198e:	df 93       	push	r29
    1990:	00 d0       	rcall	.+0      	; 0x1992 <LCD_voidSHD+0xa>
    1992:	00 d0       	rcall	.+0      	; 0x1994 <LCD_voidSHD+0xc>
    1994:	cd b7       	in	r28, 0x3d	; 61
    1996:	de b7       	in	r29, 0x3e	; 62
    1998:	08 2f       	mov	r16, r24
    199a:	84 e0       	ldi	r24, 0x04	; 4
    199c:	89 83       	std	Y+1, r24	; 0x01
    199e:	85 e0       	ldi	r24, 0x05	; 5
    19a0:	8a 83       	std	Y+2, r24	; 0x02
    19a2:	86 e0       	ldi	r24, 0x06	; 6
    19a4:	8b 83       	std	Y+3, r24	; 0x03
    19a6:	87 e0       	ldi	r24, 0x07	; 7
    19a8:	8c 83       	std	Y+4, r24	; 0x04
    19aa:	10 e0       	ldi	r17, 0x00	; 0
    19ac:	14 c0       	rjmp	.+40     	; 0x19d6 <LCD_voidSHD+0x4e>
    19ae:	40 2f       	mov	r20, r16
    19b0:	50 e0       	ldi	r21, 0x00	; 0
    19b2:	01 2e       	mov	r0, r17
    19b4:	02 c0       	rjmp	.+4      	; 0x19ba <LCD_voidSHD+0x32>
    19b6:	55 95       	asr	r21
    19b8:	47 95       	ror	r20
    19ba:	0a 94       	dec	r0
    19bc:	e2 f7       	brpl	.-8      	; 0x19b6 <LCD_voidSHD+0x2e>
    19be:	41 70       	andi	r20, 0x01	; 1
    19c0:	e1 e0       	ldi	r30, 0x01	; 1
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	ec 0f       	add	r30, r28
    19c6:	fd 1f       	adc	r31, r29
    19c8:	e1 0f       	add	r30, r17
    19ca:	f1 1d       	adc	r31, r1
    19cc:	60 81       	ld	r22, Z
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    19d4:	1f 5f       	subi	r17, 0xFF	; 255
    19d6:	14 30       	cpi	r17, 0x04	; 4
    19d8:	50 f3       	brcs	.-44     	; 0x19ae <LCD_voidSHD+0x26>
    19da:	0f 90       	pop	r0
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	df 91       	pop	r29
    19e4:	cf 91       	pop	r28
    19e6:	1f 91       	pop	r17
    19e8:	0f 91       	pop	r16
    19ea:	08 95       	ret

000019ec <LCD_voidSendEnable>:
    19ec:	41 e0       	ldi	r20, 0x01	; 1
    19ee:	62 e0       	ldi	r22, 0x02	; 2
    19f0:	81 e0       	ldi	r24, 0x01	; 1
    19f2:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    19f6:	8f e3       	ldi	r24, 0x3F	; 63
    19f8:	9f e1       	ldi	r25, 0x1F	; 31
    19fa:	01 97       	sbiw	r24, 0x01	; 1
    19fc:	f1 f7       	brne	.-4      	; 0x19fa <LCD_voidSendEnable+0xe>
    19fe:	00 c0       	rjmp	.+0      	; 0x1a00 <LCD_voidSendEnable+0x14>
    1a00:	00 00       	nop
    1a02:	40 e0       	ldi	r20, 0x00	; 0
    1a04:	62 e0       	ldi	r22, 0x02	; 2
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    1a0c:	08 95       	ret

00001a0e <LCD_voidSendData>:
    1a0e:	cf 93       	push	r28
    1a10:	c8 2f       	mov	r28, r24
    1a12:	41 e0       	ldi	r20, 0x01	; 1
    1a14:	60 e0       	ldi	r22, 0x00	; 0
    1a16:	81 e0       	ldi	r24, 0x01	; 1
    1a18:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    1a1c:	40 e0       	ldi	r20, 0x00	; 0
    1a1e:	61 e0       	ldi	r22, 0x01	; 1
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    1a26:	8c 2f       	mov	r24, r28
    1a28:	82 95       	swap	r24
    1a2a:	8f 70       	andi	r24, 0x0F	; 15
    1a2c:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a30:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a34:	8c 2f       	mov	r24, r28
    1a36:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a3a:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a3e:	cf 91       	pop	r28
    1a40:	08 95       	ret

00001a42 <LCD_voidSendCommand>:
    1a42:	cf 93       	push	r28
    1a44:	c8 2f       	mov	r28, r24
    1a46:	40 e0       	ldi	r20, 0x00	; 0
    1a48:	60 e0       	ldi	r22, 0x00	; 0
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    1a50:	40 e0       	ldi	r20, 0x00	; 0
    1a52:	61 e0       	ldi	r22, 0x01	; 1
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <DIO_voidSetPinVal>
    1a5a:	8c 2f       	mov	r24, r28
    1a5c:	82 95       	swap	r24
    1a5e:	8f 70       	andi	r24, 0x0F	; 15
    1a60:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a64:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a68:	8c 2f       	mov	r24, r28
    1a6a:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a6e:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a72:	cf 91       	pop	r28
    1a74:	08 95       	ret

00001a76 <LCD_voidInit>:
    1a76:	2f ef       	ldi	r18, 0xFF	; 255
    1a78:	83 ef       	ldi	r24, 0xF3	; 243
    1a7a:	91 e0       	ldi	r25, 0x01	; 1
    1a7c:	21 50       	subi	r18, 0x01	; 1
    1a7e:	80 40       	sbci	r24, 0x00	; 0
    1a80:	90 40       	sbci	r25, 0x00	; 0
    1a82:	e1 f7       	brne	.-8      	; 0x1a7c <LCD_voidInit+0x6>
    1a84:	00 c0       	rjmp	.+0      	; 0x1a86 <LCD_voidInit+0x10>
    1a86:	00 00       	nop
    1a88:	82 e0       	ldi	r24, 0x02	; 2
    1a8a:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a8e:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a92:	82 e0       	ldi	r24, 0x02	; 2
    1a94:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1a98:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1a9c:	88 e0       	ldi	r24, 0x08	; 8
    1a9e:	0e 94 c4 0c 	call	0x1988	; 0x1988 <LCD_voidSHD>
    1aa2:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <LCD_voidSendEnable>
    1aa6:	8c e0       	ldi	r24, 0x0C	; 12
    1aa8:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_voidSendCommand>
    1aac:	81 e0       	ldi	r24, 0x01	; 1
    1aae:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_voidSendCommand>
    1ab2:	08 95       	ret

00001ab4 <LCD_voidSendString>:
    1ab4:	0f 93       	push	r16
    1ab6:	1f 93       	push	r17
    1ab8:	cf 93       	push	r28
    1aba:	8c 01       	movw	r16, r24
    1abc:	c0 e0       	ldi	r28, 0x00	; 0
    1abe:	03 c0       	rjmp	.+6      	; 0x1ac6 <LCD_voidSendString+0x12>
    1ac0:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <LCD_voidSendData>
    1ac4:	cf 5f       	subi	r28, 0xFF	; 255
    1ac6:	f8 01       	movw	r30, r16
    1ac8:	ec 0f       	add	r30, r28
    1aca:	f1 1d       	adc	r31, r1
    1acc:	80 81       	ld	r24, Z
    1ace:	81 11       	cpse	r24, r1
    1ad0:	f7 cf       	rjmp	.-18     	; 0x1ac0 <LCD_voidSendString+0xc>
    1ad2:	cf 91       	pop	r28
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	08 95       	ret

00001ada <LCD_voidGotoxy>:
    1ada:	90 e4       	ldi	r25, 0x40	; 64
    1adc:	69 9f       	mul	r22, r25
    1ade:	80 0d       	add	r24, r0
    1ae0:	11 24       	eor	r1, r1
    1ae2:	80 68       	ori	r24, 0x80	; 128
    1ae4:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <LCD_voidSendCommand>
    1ae8:	08 95       	ret

00001aea <LCD_voidSendNumber>:
void LCD_voidSendNumber(u32 number){
    1aea:	1f 93       	push	r17
    1aec:	cf 93       	push	r28
    1aee:	df 93       	push	r29
    1af0:	cd b7       	in	r28, 0x3d	; 61
    1af2:	de b7       	in	r29, 0x3e	; 62
    1af4:	2a 97       	sbiw	r28, 0x0a	; 10
    1af6:	0f b6       	in	r0, 0x3f	; 63
    1af8:	f8 94       	cli
    1afa:	de bf       	out	0x3e, r29	; 62
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	cd bf       	out	0x3d, r28	; 61
	
	s8 i=0;
	u8 array[10] ;
	
	if(number==0){
    1b00:	61 15       	cp	r22, r1
    1b02:	71 05       	cpc	r23, r1
    1b04:	81 05       	cpc	r24, r1
    1b06:	91 05       	cpc	r25, r1
    1b08:	d1 f4       	brne	.+52     	; 0x1b3e <LCD_voidSendNumber+0x54>
		
		LCD_voidSendData('0') ;
    1b0a:	80 e3       	ldi	r24, 0x30	; 48
    1b0c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <LCD_voidSendData>
    1b10:	2c c0       	rjmp	.+88     	; 0x1b6a <LCD_voidSendNumber+0x80>
		return ;
	}
	for(i=0; number!=0 ;i++){
		
		array[i]= number % 10 + 48 ;
    1b12:	2a e0       	ldi	r18, 0x0A	; 10
    1b14:	30 e0       	ldi	r19, 0x00	; 0
    1b16:	40 e0       	ldi	r20, 0x00	; 0
    1b18:	50 e0       	ldi	r21, 0x00	; 0
    1b1a:	0e 94 22 11 	call	0x2244	; 0x2244 <__udivmodsi4>
    1b1e:	e1 e0       	ldi	r30, 0x01	; 1
    1b20:	f0 e0       	ldi	r31, 0x00	; 0
    1b22:	ec 0f       	add	r30, r28
    1b24:	fd 1f       	adc	r31, r29
    1b26:	e1 0f       	add	r30, r17
    1b28:	f1 1d       	adc	r31, r1
    1b2a:	17 fd       	sbrc	r17, 7
    1b2c:	fa 95       	dec	r31
    1b2e:	60 5d       	subi	r22, 0xD0	; 208
    1b30:	60 83       	st	Z, r22
		number /= 10 ;
    1b32:	62 2f       	mov	r22, r18
    1b34:	73 2f       	mov	r23, r19
    1b36:	84 2f       	mov	r24, r20
    1b38:	95 2f       	mov	r25, r21
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
    1b3a:	1f 5f       	subi	r17, 0xFF	; 255
    1b3c:	01 c0       	rjmp	.+2      	; 0x1b40 <LCD_voidSendNumber+0x56>
    1b3e:	10 e0       	ldi	r17, 0x00	; 0
    1b40:	61 15       	cp	r22, r1
    1b42:	71 05       	cpc	r23, r1
    1b44:	81 05       	cpc	r24, r1
    1b46:	91 05       	cpc	r25, r1
    1b48:	21 f7       	brne	.-56     	; 0x1b12 <LCD_voidSendNumber+0x28>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
    1b4a:	11 50       	subi	r17, 0x01	; 1
	while(i >= 0){
    1b4c:	0c c0       	rjmp	.+24     	; 0x1b66 <LCD_voidSendNumber+0x7c>
		
		LCD_voidSendData(array[i]) ;
    1b4e:	e1 e0       	ldi	r30, 0x01	; 1
    1b50:	f0 e0       	ldi	r31, 0x00	; 0
    1b52:	ec 0f       	add	r30, r28
    1b54:	fd 1f       	adc	r31, r29
    1b56:	e1 0f       	add	r30, r17
    1b58:	f1 1d       	adc	r31, r1
    1b5a:	17 fd       	sbrc	r17, 7
    1b5c:	fa 95       	dec	r31
    1b5e:	80 81       	ld	r24, Z
    1b60:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <LCD_voidSendData>
		i-- ;
    1b64:	11 50       	subi	r17, 0x01	; 1
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
    1b66:	11 23       	and	r17, r17
    1b68:	94 f7       	brge	.-28     	; 0x1b4e <LCD_voidSendNumber+0x64>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
    1b6a:	2a 96       	adiw	r28, 0x0a	; 10
    1b6c:	0f b6       	in	r0, 0x3f	; 63
    1b6e:	f8 94       	cli
    1b70:	de bf       	out	0x3e, r29	; 62
    1b72:	0f be       	out	0x3f, r0	; 63
    1b74:	cd bf       	out	0x3d, r28	; 61
    1b76:	df 91       	pop	r29
    1b78:	cf 91       	pop	r28
    1b7a:	1f 91       	pop	r17
    1b7c:	08 95       	ret

00001b7e <ADC_voidInit>:


void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
    1b7e:	87 b1       	in	r24, 0x07	; 7
    1b80:	8f 77       	andi	r24, 0x7F	; 127
    1b82:	87 b9       	out	0x07, r24	; 7
	 SET_BIT(ADMUX_REG,6) ; 
    1b84:	87 b1       	in	r24, 0x07	; 7
    1b86:	80 64       	ori	r24, 0x40	; 64
    1b88:	87 b9       	out	0x07, r24	; 7
	 
	/*select prescaler */
	 
	 ADCSRA_REG&=0b11111000 ; 
    1b8a:	86 b1       	in	r24, 0x06	; 6
    1b8c:	88 7f       	andi	r24, 0xF8	; 248
    1b8e:	86 b9       	out	0x06, r24	; 6
	 ADCSRA_REG|=ADC_PRESCALER ; 
    1b90:	86 b1       	in	r24, 0x06	; 6
    1b92:	87 60       	ori	r24, 0x07	; 7
    1b94:	86 b9       	out	0x06, r24	; 6
	
	
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
    1b96:	86 b1       	in	r24, 0x06	; 6
    1b98:	80 68       	ori	r24, 0x80	; 128
    1b9a:	86 b9       	out	0x06, r24	; 6
    1b9c:	08 95       	ret

00001b9e <ADC_u16ReadChannel>:
}

u16 ADC_u16ReadChannel(u8 copy_u8channel){
	
	  /* select channel */
	  ADMUX_REG &=0b11100000 ; 
    1b9e:	97 b1       	in	r25, 0x07	; 7
    1ba0:	90 7e       	andi	r25, 0xE0	; 224
    1ba2:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG |=copy_u8channel ; 
    1ba4:	97 b1       	in	r25, 0x07	; 7
    1ba6:	89 2b       	or	r24, r25
    1ba8:	87 b9       	out	0x07, r24	; 7
	  /* start conversion */
	  SET_BIT(ADCSRA_REG,6) ; 
    1baa:	86 b1       	in	r24, 0x06	; 6
    1bac:	80 64       	ori	r24, 0x40	; 64
    1bae:	86 b9       	out	0x06, r24	; 6
	  
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
    1bb0:	34 9b       	sbis	0x06, 4	; 6
    1bb2:	fe cf       	rjmp	.-4      	; 0x1bb0 <ADC_u16ReadChannel+0x12>
	  
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
    1bb4:	86 b1       	in	r24, 0x06	; 6
    1bb6:	80 61       	ori	r24, 0x10	; 16
    1bb8:	86 b9       	out	0x06, r24	; 6
	  
	  return  ADC_REG ; 
    1bba:	84 b1       	in	r24, 0x04	; 4
    1bbc:	95 b1       	in	r25, 0x05	; 5

    1bbe:	08 95       	ret

00001bc0 <DIO_voidSetPinDir>:
	
	
	return Loc_u8Val ; 
	
	
}
    1bc0:	42 30       	cpi	r20, 0x02	; 2
    1bc2:	08 f0       	brcs	.+2      	; 0x1bc6 <DIO_voidSetPinDir+0x6>
    1bc4:	6f c0       	rjmp	.+222    	; 0x1ca4 <DIO_voidSetPinDir+0xe4>
    1bc6:	41 30       	cpi	r20, 0x01	; 1
    1bc8:	a1 f5       	brne	.+104    	; 0x1c32 <DIO_voidSetPinDir+0x72>
    1bca:	81 30       	cpi	r24, 0x01	; 1
    1bcc:	89 f0       	breq	.+34     	; 0x1bf0 <DIO_voidSetPinDir+0x30>
    1bce:	28 f0       	brcs	.+10     	; 0x1bda <DIO_voidSetPinDir+0x1a>
    1bd0:	82 30       	cpi	r24, 0x02	; 2
    1bd2:	c9 f0       	breq	.+50     	; 0x1c06 <DIO_voidSetPinDir+0x46>
    1bd4:	83 30       	cpi	r24, 0x03	; 3
    1bd6:	11 f1       	breq	.+68     	; 0x1c1c <DIO_voidSetPinDir+0x5c>
    1bd8:	08 95       	ret
    1bda:	2a b3       	in	r18, 0x1a	; 26
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	90 e0       	ldi	r25, 0x00	; 0
    1be0:	02 c0       	rjmp	.+4      	; 0x1be6 <DIO_voidSetPinDir+0x26>
    1be2:	88 0f       	add	r24, r24
    1be4:	99 1f       	adc	r25, r25
    1be6:	6a 95       	dec	r22
    1be8:	e2 f7       	brpl	.-8      	; 0x1be2 <DIO_voidSetPinDir+0x22>
    1bea:	82 2b       	or	r24, r18
    1bec:	8a bb       	out	0x1a, r24	; 26
    1bee:	08 95       	ret
    1bf0:	27 b3       	in	r18, 0x17	; 23
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	90 e0       	ldi	r25, 0x00	; 0
    1bf6:	02 c0       	rjmp	.+4      	; 0x1bfc <DIO_voidSetPinDir+0x3c>
    1bf8:	88 0f       	add	r24, r24
    1bfa:	99 1f       	adc	r25, r25
    1bfc:	6a 95       	dec	r22
    1bfe:	e2 f7       	brpl	.-8      	; 0x1bf8 <DIO_voidSetPinDir+0x38>
    1c00:	82 2b       	or	r24, r18
    1c02:	87 bb       	out	0x17, r24	; 23
    1c04:	08 95       	ret
    1c06:	24 b3       	in	r18, 0x14	; 20
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	02 c0       	rjmp	.+4      	; 0x1c12 <DIO_voidSetPinDir+0x52>
    1c0e:	88 0f       	add	r24, r24
    1c10:	99 1f       	adc	r25, r25
    1c12:	6a 95       	dec	r22
    1c14:	e2 f7       	brpl	.-8      	; 0x1c0e <DIO_voidSetPinDir+0x4e>
    1c16:	82 2b       	or	r24, r18
    1c18:	84 bb       	out	0x14, r24	; 20
    1c1a:	08 95       	ret
    1c1c:	21 b3       	in	r18, 0x11	; 17
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	02 c0       	rjmp	.+4      	; 0x1c28 <DIO_voidSetPinDir+0x68>
    1c24:	88 0f       	add	r24, r24
    1c26:	99 1f       	adc	r25, r25
    1c28:	6a 95       	dec	r22
    1c2a:	e2 f7       	brpl	.-8      	; 0x1c24 <DIO_voidSetPinDir+0x64>
    1c2c:	82 2b       	or	r24, r18
    1c2e:	81 bb       	out	0x11, r24	; 17
    1c30:	08 95       	ret
    1c32:	41 11       	cpse	r20, r1
    1c34:	37 c0       	rjmp	.+110    	; 0x1ca4 <DIO_voidSetPinDir+0xe4>
    1c36:	81 30       	cpi	r24, 0x01	; 1
    1c38:	91 f0       	breq	.+36     	; 0x1c5e <DIO_voidSetPinDir+0x9e>
    1c3a:	28 f0       	brcs	.+10     	; 0x1c46 <DIO_voidSetPinDir+0x86>
    1c3c:	82 30       	cpi	r24, 0x02	; 2
    1c3e:	d9 f0       	breq	.+54     	; 0x1c76 <DIO_voidSetPinDir+0xb6>
    1c40:	83 30       	cpi	r24, 0x03	; 3
    1c42:	29 f1       	breq	.+74     	; 0x1c8e <DIO_voidSetPinDir+0xce>
    1c44:	08 95       	ret
    1c46:	2a b3       	in	r18, 0x1a	; 26
    1c48:	81 e0       	ldi	r24, 0x01	; 1
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	02 c0       	rjmp	.+4      	; 0x1c52 <DIO_voidSetPinDir+0x92>
    1c4e:	88 0f       	add	r24, r24
    1c50:	99 1f       	adc	r25, r25
    1c52:	6a 95       	dec	r22
    1c54:	e2 f7       	brpl	.-8      	; 0x1c4e <DIO_voidSetPinDir+0x8e>
    1c56:	80 95       	com	r24
    1c58:	82 23       	and	r24, r18
    1c5a:	8a bb       	out	0x1a, r24	; 26
    1c5c:	08 95       	ret
    1c5e:	27 b3       	in	r18, 0x17	; 23
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	02 c0       	rjmp	.+4      	; 0x1c6a <DIO_voidSetPinDir+0xaa>
    1c66:	88 0f       	add	r24, r24
    1c68:	99 1f       	adc	r25, r25
    1c6a:	6a 95       	dec	r22
    1c6c:	e2 f7       	brpl	.-8      	; 0x1c66 <DIO_voidSetPinDir+0xa6>
    1c6e:	80 95       	com	r24
    1c70:	82 23       	and	r24, r18
    1c72:	87 bb       	out	0x17, r24	; 23
    1c74:	08 95       	ret
    1c76:	24 b3       	in	r18, 0x14	; 20
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	02 c0       	rjmp	.+4      	; 0x1c82 <DIO_voidSetPinDir+0xc2>
    1c7e:	88 0f       	add	r24, r24
    1c80:	99 1f       	adc	r25, r25
    1c82:	6a 95       	dec	r22
    1c84:	e2 f7       	brpl	.-8      	; 0x1c7e <DIO_voidSetPinDir+0xbe>
    1c86:	80 95       	com	r24
    1c88:	82 23       	and	r24, r18
    1c8a:	84 bb       	out	0x14, r24	; 20
    1c8c:	08 95       	ret
    1c8e:	21 b3       	in	r18, 0x11	; 17
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	02 c0       	rjmp	.+4      	; 0x1c9a <DIO_voidSetPinDir+0xda>
    1c96:	88 0f       	add	r24, r24
    1c98:	99 1f       	adc	r25, r25
    1c9a:	6a 95       	dec	r22
    1c9c:	e2 f7       	brpl	.-8      	; 0x1c96 <DIO_voidSetPinDir+0xd6>
    1c9e:	80 95       	com	r24
    1ca0:	82 23       	and	r24, r18
    1ca2:	81 bb       	out	0x11, r24	; 17
    1ca4:	08 95       	ret

00001ca6 <DIO_voidSetPinVal>:
    1ca6:	42 30       	cpi	r20, 0x02	; 2
    1ca8:	08 f0       	brcs	.+2      	; 0x1cac <DIO_voidSetPinVal+0x6>
    1caa:	6f c0       	rjmp	.+222    	; 0x1d8a <DIO_voidSetPinVal+0xe4>
    1cac:	41 30       	cpi	r20, 0x01	; 1
    1cae:	a1 f5       	brne	.+104    	; 0x1d18 <DIO_voidSetPinVal+0x72>
    1cb0:	81 30       	cpi	r24, 0x01	; 1
    1cb2:	89 f0       	breq	.+34     	; 0x1cd6 <DIO_voidSetPinVal+0x30>
    1cb4:	28 f0       	brcs	.+10     	; 0x1cc0 <DIO_voidSetPinVal+0x1a>
    1cb6:	82 30       	cpi	r24, 0x02	; 2
    1cb8:	c9 f0       	breq	.+50     	; 0x1cec <DIO_voidSetPinVal+0x46>
    1cba:	83 30       	cpi	r24, 0x03	; 3
    1cbc:	11 f1       	breq	.+68     	; 0x1d02 <DIO_voidSetPinVal+0x5c>
    1cbe:	08 95       	ret
    1cc0:	2b b3       	in	r18, 0x1b	; 27
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	02 c0       	rjmp	.+4      	; 0x1ccc <DIO_voidSetPinVal+0x26>
    1cc8:	88 0f       	add	r24, r24
    1cca:	99 1f       	adc	r25, r25
    1ccc:	6a 95       	dec	r22
    1cce:	e2 f7       	brpl	.-8      	; 0x1cc8 <DIO_voidSetPinVal+0x22>
    1cd0:	82 2b       	or	r24, r18
    1cd2:	8b bb       	out	0x1b, r24	; 27
    1cd4:	08 95       	ret
    1cd6:	28 b3       	in	r18, 0x18	; 24
    1cd8:	81 e0       	ldi	r24, 0x01	; 1
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	02 c0       	rjmp	.+4      	; 0x1ce2 <DIO_voidSetPinVal+0x3c>
    1cde:	88 0f       	add	r24, r24
    1ce0:	99 1f       	adc	r25, r25
    1ce2:	6a 95       	dec	r22
    1ce4:	e2 f7       	brpl	.-8      	; 0x1cde <DIO_voidSetPinVal+0x38>
    1ce6:	82 2b       	or	r24, r18
    1ce8:	88 bb       	out	0x18, r24	; 24
    1cea:	08 95       	ret
    1cec:	25 b3       	in	r18, 0x15	; 21
    1cee:	81 e0       	ldi	r24, 0x01	; 1
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	02 c0       	rjmp	.+4      	; 0x1cf8 <DIO_voidSetPinVal+0x52>
    1cf4:	88 0f       	add	r24, r24
    1cf6:	99 1f       	adc	r25, r25
    1cf8:	6a 95       	dec	r22
    1cfa:	e2 f7       	brpl	.-8      	; 0x1cf4 <DIO_voidSetPinVal+0x4e>
    1cfc:	82 2b       	or	r24, r18
    1cfe:	85 bb       	out	0x15, r24	; 21
    1d00:	08 95       	ret
    1d02:	22 b3       	in	r18, 0x12	; 18
    1d04:	81 e0       	ldi	r24, 0x01	; 1
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	02 c0       	rjmp	.+4      	; 0x1d0e <DIO_voidSetPinVal+0x68>
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	6a 95       	dec	r22
    1d10:	e2 f7       	brpl	.-8      	; 0x1d0a <DIO_voidSetPinVal+0x64>
    1d12:	82 2b       	or	r24, r18
    1d14:	82 bb       	out	0x12, r24	; 18
    1d16:	08 95       	ret
    1d18:	41 11       	cpse	r20, r1
    1d1a:	37 c0       	rjmp	.+110    	; 0x1d8a <DIO_voidSetPinVal+0xe4>
    1d1c:	81 30       	cpi	r24, 0x01	; 1
    1d1e:	91 f0       	breq	.+36     	; 0x1d44 <DIO_voidSetPinVal+0x9e>
    1d20:	28 f0       	brcs	.+10     	; 0x1d2c <DIO_voidSetPinVal+0x86>
    1d22:	82 30       	cpi	r24, 0x02	; 2
    1d24:	d9 f0       	breq	.+54     	; 0x1d5c <DIO_voidSetPinVal+0xb6>
    1d26:	83 30       	cpi	r24, 0x03	; 3
    1d28:	29 f1       	breq	.+74     	; 0x1d74 <DIO_voidSetPinVal+0xce>
    1d2a:	08 95       	ret
    1d2c:	2b b3       	in	r18, 0x1b	; 27
    1d2e:	81 e0       	ldi	r24, 0x01	; 1
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	02 c0       	rjmp	.+4      	; 0x1d38 <DIO_voidSetPinVal+0x92>
    1d34:	88 0f       	add	r24, r24
    1d36:	99 1f       	adc	r25, r25
    1d38:	6a 95       	dec	r22
    1d3a:	e2 f7       	brpl	.-8      	; 0x1d34 <DIO_voidSetPinVal+0x8e>
    1d3c:	80 95       	com	r24
    1d3e:	82 23       	and	r24, r18
    1d40:	8b bb       	out	0x1b, r24	; 27
    1d42:	08 95       	ret
    1d44:	28 b3       	in	r18, 0x18	; 24
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	02 c0       	rjmp	.+4      	; 0x1d50 <DIO_voidSetPinVal+0xaa>
    1d4c:	88 0f       	add	r24, r24
    1d4e:	99 1f       	adc	r25, r25
    1d50:	6a 95       	dec	r22
    1d52:	e2 f7       	brpl	.-8      	; 0x1d4c <DIO_voidSetPinVal+0xa6>
    1d54:	80 95       	com	r24
    1d56:	82 23       	and	r24, r18
    1d58:	88 bb       	out	0x18, r24	; 24
    1d5a:	08 95       	ret
    1d5c:	25 b3       	in	r18, 0x15	; 21
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	02 c0       	rjmp	.+4      	; 0x1d68 <DIO_voidSetPinVal+0xc2>
    1d64:	88 0f       	add	r24, r24
    1d66:	99 1f       	adc	r25, r25
    1d68:	6a 95       	dec	r22
    1d6a:	e2 f7       	brpl	.-8      	; 0x1d64 <DIO_voidSetPinVal+0xbe>
    1d6c:	80 95       	com	r24
    1d6e:	82 23       	and	r24, r18
    1d70:	85 bb       	out	0x15, r24	; 21
    1d72:	08 95       	ret
    1d74:	22 b3       	in	r18, 0x12	; 18
    1d76:	81 e0       	ldi	r24, 0x01	; 1
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	02 c0       	rjmp	.+4      	; 0x1d80 <DIO_voidSetPinVal+0xda>
    1d7c:	88 0f       	add	r24, r24
    1d7e:	99 1f       	adc	r25, r25
    1d80:	6a 95       	dec	r22
    1d82:	e2 f7       	brpl	.-8      	; 0x1d7c <DIO_voidSetPinVal+0xd6>
    1d84:	80 95       	com	r24
    1d86:	82 23       	and	r24, r18
    1d88:	82 bb       	out	0x12, r24	; 18
    1d8a:	08 95       	ret

00001d8c <DIO_voidSetPortDir>:


void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir){
	
	switch(copy_u8port){
    1d8c:	81 30       	cpi	r24, 0x01	; 1
    1d8e:	41 f0       	breq	.+16     	; 0x1da0 <DIO_voidSetPortDir+0x14>
    1d90:	28 f0       	brcs	.+10     	; 0x1d9c <DIO_voidSetPortDir+0x10>
    1d92:	82 30       	cpi	r24, 0x02	; 2
    1d94:	39 f0       	breq	.+14     	; 0x1da4 <DIO_voidSetPortDir+0x18>
    1d96:	83 30       	cpi	r24, 0x03	; 3
    1d98:	39 f0       	breq	.+14     	; 0x1da8 <DIO_voidSetPortDir+0x1c>
    1d9a:	08 95       	ret
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ;break ; 
    1d9c:	6a bb       	out	0x1a, r22	; 26
    1d9e:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ;break ;
    1da0:	67 bb       	out	0x17, r22	; 23
    1da2:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ;break ;
    1da4:	64 bb       	out	0x14, r22	; 20
    1da6:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ;break ;
    1da8:	61 bb       	out	0x11, r22	; 17
    1daa:	08 95       	ret

00001dac <__vector_1>:
}


/*int0*/
void __vector_1(void)__attribute__((signal)) ;
void __vector_1(void){
    1dac:	1f 92       	push	r1
    1dae:	0f 92       	push	r0
    1db0:	0f b6       	in	r0, 0x3f	; 63
    1db2:	0f 92       	push	r0
    1db4:	11 24       	eor	r1, r1
    1db6:	2f 93       	push	r18
    1db8:	3f 93       	push	r19
    1dba:	4f 93       	push	r20
    1dbc:	5f 93       	push	r21
    1dbe:	6f 93       	push	r22
    1dc0:	7f 93       	push	r23
    1dc2:	8f 93       	push	r24
    1dc4:	9f 93       	push	r25
    1dc6:	af 93       	push	r26
    1dc8:	bf 93       	push	r27
    1dca:	ef 93       	push	r30
    1dcc:	ff 93       	push	r31
	
	 EXTI_PTR[0]() ; 
    1dce:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <EXTI_PTR>
    1dd2:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <EXTI_PTR+0x1>
    1dd6:	09 95       	icall
	
	
}
    1dd8:	ff 91       	pop	r31
    1dda:	ef 91       	pop	r30
    1ddc:	bf 91       	pop	r27
    1dde:	af 91       	pop	r26
    1de0:	9f 91       	pop	r25
    1de2:	8f 91       	pop	r24
    1de4:	7f 91       	pop	r23
    1de6:	6f 91       	pop	r22
    1de8:	5f 91       	pop	r21
    1dea:	4f 91       	pop	r20
    1dec:	3f 91       	pop	r19
    1dee:	2f 91       	pop	r18
    1df0:	0f 90       	pop	r0
    1df2:	0f be       	out	0x3f, r0	; 63
    1df4:	0f 90       	pop	r0
    1df6:	1f 90       	pop	r1
    1df8:	18 95       	reti

00001dfa <__vector_2>:

/*int1*/
void __vector_2(void)__attribute__((signal)) ;
void __vector_2(void){
    1dfa:	1f 92       	push	r1
    1dfc:	0f 92       	push	r0
    1dfe:	0f b6       	in	r0, 0x3f	; 63
    1e00:	0f 92       	push	r0
    1e02:	11 24       	eor	r1, r1
    1e04:	2f 93       	push	r18
    1e06:	3f 93       	push	r19
    1e08:	4f 93       	push	r20
    1e0a:	5f 93       	push	r21
    1e0c:	6f 93       	push	r22
    1e0e:	7f 93       	push	r23
    1e10:	8f 93       	push	r24
    1e12:	9f 93       	push	r25
    1e14:	af 93       	push	r26
    1e16:	bf 93       	push	r27
    1e18:	ef 93       	push	r30
    1e1a:	ff 93       	push	r31
	
	
EXTI_PTR[1]() ; 
    1e1c:	e0 91 50 05 	lds	r30, 0x0550	; 0x800550 <EXTI_PTR+0x2>
    1e20:	f0 91 51 05 	lds	r31, 0x0551	; 0x800551 <EXTI_PTR+0x3>
    1e24:	09 95       	icall
	
	
}
    1e26:	ff 91       	pop	r31
    1e28:	ef 91       	pop	r30
    1e2a:	bf 91       	pop	r27
    1e2c:	af 91       	pop	r26
    1e2e:	9f 91       	pop	r25
    1e30:	8f 91       	pop	r24
    1e32:	7f 91       	pop	r23
    1e34:	6f 91       	pop	r22
    1e36:	5f 91       	pop	r21
    1e38:	4f 91       	pop	r20
    1e3a:	3f 91       	pop	r19
    1e3c:	2f 91       	pop	r18
    1e3e:	0f 90       	pop	r0
    1e40:	0f be       	out	0x3f, r0	; 63
    1e42:	0f 90       	pop	r0
    1e44:	1f 90       	pop	r1
    1e46:	18 95       	reti

00001e48 <__vector_3>:
/*int2 */
void __vector_3(void)__attribute__((signal)) ;
void __vector_3(void){
    1e48:	1f 92       	push	r1
    1e4a:	0f 92       	push	r0
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	0f 92       	push	r0
    1e50:	11 24       	eor	r1, r1
    1e52:	2f 93       	push	r18
    1e54:	3f 93       	push	r19
    1e56:	4f 93       	push	r20
    1e58:	5f 93       	push	r21
    1e5a:	6f 93       	push	r22
    1e5c:	7f 93       	push	r23
    1e5e:	8f 93       	push	r24
    1e60:	9f 93       	push	r25
    1e62:	af 93       	push	r26
    1e64:	bf 93       	push	r27
    1e66:	ef 93       	push	r30
    1e68:	ff 93       	push	r31
	
	
	EXTI_PTR[2]() ; 
    1e6a:	e0 91 52 05 	lds	r30, 0x0552	; 0x800552 <EXTI_PTR+0x4>
    1e6e:	f0 91 53 05 	lds	r31, 0x0553	; 0x800553 <EXTI_PTR+0x5>
    1e72:	09 95       	icall
	
	
}
    1e74:	ff 91       	pop	r31
    1e76:	ef 91       	pop	r30
    1e78:	bf 91       	pop	r27
    1e7a:	af 91       	pop	r26
    1e7c:	9f 91       	pop	r25
    1e7e:	8f 91       	pop	r24
    1e80:	7f 91       	pop	r23
    1e82:	6f 91       	pop	r22
    1e84:	5f 91       	pop	r21
    1e86:	4f 91       	pop	r20
    1e88:	3f 91       	pop	r19
    1e8a:	2f 91       	pop	r18
    1e8c:	0f 90       	pop	r0
    1e8e:	0f be       	out	0x3f, r0	; 63
    1e90:	0f 90       	pop	r0
    1e92:	1f 90       	pop	r1
    1e94:	18 95       	reti

00001e96 <__vector_11>:
			}
	
}

void __vector_11(void)__attribute__((signal)) ;
void __vector_11(void){
    1e96:	1f 92       	push	r1
    1e98:	0f 92       	push	r0
    1e9a:	0f b6       	in	r0, 0x3f	; 63
    1e9c:	0f 92       	push	r0
    1e9e:	11 24       	eor	r1, r1
    1ea0:	2f 93       	push	r18
    1ea2:	3f 93       	push	r19
    1ea4:	4f 93       	push	r20
    1ea6:	5f 93       	push	r21
    1ea8:	6f 93       	push	r22
    1eaa:	7f 93       	push	r23
    1eac:	8f 93       	push	r24
    1eae:	9f 93       	push	r25
    1eb0:	af 93       	push	r26
    1eb2:	bf 93       	push	r27
    1eb4:	ef 93       	push	r30
    1eb6:	ff 93       	push	r31
	

TIM0_PTR[0]() ; 
    1eb8:	e0 91 54 05 	lds	r30, 0x0554	; 0x800554 <TIM0_PTR>
    1ebc:	f0 91 55 05 	lds	r31, 0x0555	; 0x800555 <TIM0_PTR+0x1>
    1ec0:	09 95       	icall


}
    1ec2:	ff 91       	pop	r31
    1ec4:	ef 91       	pop	r30
    1ec6:	bf 91       	pop	r27
    1ec8:	af 91       	pop	r26
    1eca:	9f 91       	pop	r25
    1ecc:	8f 91       	pop	r24
    1ece:	7f 91       	pop	r23
    1ed0:	6f 91       	pop	r22
    1ed2:	5f 91       	pop	r21
    1ed4:	4f 91       	pop	r20
    1ed6:	3f 91       	pop	r19
    1ed8:	2f 91       	pop	r18
    1eda:	0f 90       	pop	r0
    1edc:	0f be       	out	0x3f, r0	; 63
    1ede:	0f 90       	pop	r0
    1ee0:	1f 90       	pop	r1
    1ee2:	18 95       	reti

00001ee4 <__vector_10>:


*/

void __vector_10(void)__attribute__((signal)) ;
void __vector_10(void){
    1ee4:	1f 92       	push	r1
    1ee6:	0f 92       	push	r0
    1ee8:	0f b6       	in	r0, 0x3f	; 63
    1eea:	0f 92       	push	r0
    1eec:	11 24       	eor	r1, r1
    1eee:	2f 93       	push	r18
    1ef0:	3f 93       	push	r19
    1ef2:	4f 93       	push	r20
    1ef4:	5f 93       	push	r21
    1ef6:	6f 93       	push	r22
    1ef8:	7f 93       	push	r23
    1efa:	8f 93       	push	r24
    1efc:	9f 93       	push	r25
    1efe:	af 93       	push	r26
    1f00:	bf 93       	push	r27
    1f02:	ef 93       	push	r30
    1f04:	ff 93       	push	r31
	

TIM0_PTR[1]() ;
    1f06:	e0 91 56 05 	lds	r30, 0x0556	; 0x800556 <TIM0_PTR+0x2>
    1f0a:	f0 91 57 05 	lds	r31, 0x0557	; 0x800557 <TIM0_PTR+0x3>
    1f0e:	09 95       	icall

}
    1f10:	ff 91       	pop	r31
    1f12:	ef 91       	pop	r30
    1f14:	bf 91       	pop	r27
    1f16:	af 91       	pop	r26
    1f18:	9f 91       	pop	r25
    1f1a:	8f 91       	pop	r24
    1f1c:	7f 91       	pop	r23
    1f1e:	6f 91       	pop	r22
    1f20:	5f 91       	pop	r21
    1f22:	4f 91       	pop	r20
    1f24:	3f 91       	pop	r19
    1f26:	2f 91       	pop	r18
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	0f 90       	pop	r0
    1f2e:	1f 90       	pop	r1
    1f30:	18 95       	reti

00001f32 <TIMER0_voidFastPWM>:

void TIMER0_voidFastPWM(u8 copy_u8dc){
	/*1- select mode : fast pwm*/
	SET_BIT(TCCR0_REG,3);
    1f32:	93 b7       	in	r25, 0x33	; 51
    1f34:	98 60       	ori	r25, 0x08	; 8
    1f36:	93 bf       	out	0x33, r25	; 51
	SET_BIT(TCCR0_REG,6);
    1f38:	93 b7       	in	r25, 0x33	; 51
    1f3a:	90 64       	ori	r25, 0x40	; 64
    1f3c:	93 bf       	out	0x33, r25	; 51
	/*2- non inverting*/
	SET_BIT(TCCR0_REG,5);
    1f3e:	93 b7       	in	r25, 0x33	; 51
    1f40:	90 62       	ori	r25, 0x20	; 32
    1f42:	93 bf       	out	0x33, r25	; 51
	CLR_BIT(TCCR0_REG,4);
    1f44:	93 b7       	in	r25, 0x33	; 51
    1f46:	9f 7e       	andi	r25, 0xEF	; 239
    1f48:	93 bf       	out	0x33, r25	; 51
	/*3- set prescler*/
	TCCR0_REG &= 0b11111000;
    1f4a:	93 b7       	in	r25, 0x33	; 51
    1f4c:	98 7f       	andi	r25, 0xF8	; 248
    1f4e:	93 bf       	out	0x33, r25	; 51
	TCCR0_REG |= TIME0_PRESCALER ;
    1f50:	93 b7       	in	r25, 0x33	; 51
    1f52:	93 60       	ori	r25, 0x03	; 3
    1f54:	93 bf       	out	0x33, r25	; 51
	OCR0_REG = copy_u8dc*2.56;
    1f56:	68 2f       	mov	r22, r24
    1f58:	70 e0       	ldi	r23, 0x00	; 0
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	0e 94 00 10 	call	0x2000	; 0x2000 <__floatsisf>
    1f62:	2a e0       	ldi	r18, 0x0A	; 10
    1f64:	37 ed       	ldi	r19, 0xD7	; 215
    1f66:	43 e2       	ldi	r20, 0x23	; 35
    1f68:	50 e4       	ldi	r21, 0x40	; 64
    1f6a:	0e 94 8d 10 	call	0x211a	; 0x211a <__mulsf3>
    1f6e:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <__fixunssfsi>
    1f72:	6c bf       	out	0x3c, r22	; 60
    1f74:	08 95       	ret

00001f76 <UART_voidInit>:
	/* SET DATA */
	UDR_REG=copy_u8data ; 
	while(GET_BIT(UCSRA_REG,5)==0) ; 
	
	
}
    1f76:	86 e8       	ldi	r24, 0x86	; 134
    1f78:	80 bd       	out	0x20, r24	; 32
    1f7a:	87 e6       	ldi	r24, 0x67	; 103
    1f7c:	89 b9       	out	0x09, r24	; 9
    1f7e:	8a b1       	in	r24, 0x0a	; 10
    1f80:	88 60       	ori	r24, 0x08	; 8
    1f82:	8a b9       	out	0x0a, r24	; 10
    1f84:	8a b1       	in	r24, 0x0a	; 10
    1f86:	80 61       	ori	r24, 0x10	; 16
    1f88:	8a b9       	out	0x0a, r24	; 10
    1f8a:	08 95       	ret

00001f8c <UART_u8RX>:
u8 UART_u8RX(void) {
	
	while(GET_BIT(UCSRA_REG,7)==0) ; 
    1f8c:	5f 9b       	sbis	0x0b, 7	; 11
    1f8e:	fe cf       	rjmp	.-4      	; 0x1f8c <UART_u8RX>
	
	return UDR_REG ;  // RETURN VALUE 
    1f90:	8c b1       	in	r24, 0x0c	; 12
    1f92:	08 95       	ret

00001f94 <__cmpsf2>:
    1f94:	0e 94 3b 10 	call	0x2076	; 0x2076 <__fp_cmp>
    1f98:	08 f4       	brcc	.+2      	; 0x1f9c <__cmpsf2+0x8>
    1f9a:	81 e0       	ldi	r24, 0x01	; 1
    1f9c:	08 95       	ret

00001f9e <__fixunssfsi>:
    1f9e:	0e 94 67 10 	call	0x20ce	; 0x20ce <__fp_splitA>
    1fa2:	88 f0       	brcs	.+34     	; 0x1fc6 <__fixunssfsi+0x28>
    1fa4:	9f 57       	subi	r25, 0x7F	; 127
    1fa6:	98 f0       	brcs	.+38     	; 0x1fce <__fixunssfsi+0x30>
    1fa8:	b9 2f       	mov	r27, r25
    1faa:	99 27       	eor	r25, r25
    1fac:	b7 51       	subi	r27, 0x17	; 23
    1fae:	b0 f0       	brcs	.+44     	; 0x1fdc <__fixunssfsi+0x3e>
    1fb0:	e1 f0       	breq	.+56     	; 0x1fea <__fixunssfsi+0x4c>
    1fb2:	66 0f       	add	r22, r22
    1fb4:	77 1f       	adc	r23, r23
    1fb6:	88 1f       	adc	r24, r24
    1fb8:	99 1f       	adc	r25, r25
    1fba:	1a f0       	brmi	.+6      	; 0x1fc2 <__fixunssfsi+0x24>
    1fbc:	ba 95       	dec	r27
    1fbe:	c9 f7       	brne	.-14     	; 0x1fb2 <__fixunssfsi+0x14>
    1fc0:	14 c0       	rjmp	.+40     	; 0x1fea <__fixunssfsi+0x4c>
    1fc2:	b1 30       	cpi	r27, 0x01	; 1
    1fc4:	91 f0       	breq	.+36     	; 0x1fea <__fixunssfsi+0x4c>
    1fc6:	0e 94 81 10 	call	0x2102	; 0x2102 <__fp_zero>
    1fca:	b1 e0       	ldi	r27, 0x01	; 1
    1fcc:	08 95       	ret
    1fce:	0c 94 81 10 	jmp	0x2102	; 0x2102 <__fp_zero>
    1fd2:	67 2f       	mov	r22, r23
    1fd4:	78 2f       	mov	r23, r24
    1fd6:	88 27       	eor	r24, r24
    1fd8:	b8 5f       	subi	r27, 0xF8	; 248
    1fda:	39 f0       	breq	.+14     	; 0x1fea <__fixunssfsi+0x4c>
    1fdc:	b9 3f       	cpi	r27, 0xF9	; 249
    1fde:	cc f3       	brlt	.-14     	; 0x1fd2 <__fixunssfsi+0x34>
    1fe0:	86 95       	lsr	r24
    1fe2:	77 95       	ror	r23
    1fe4:	67 95       	ror	r22
    1fe6:	b3 95       	inc	r27
    1fe8:	d9 f7       	brne	.-10     	; 0x1fe0 <__fixunssfsi+0x42>
    1fea:	3e f4       	brtc	.+14     	; 0x1ffa <__fixunssfsi+0x5c>
    1fec:	90 95       	com	r25
    1fee:	80 95       	com	r24
    1ff0:	70 95       	com	r23
    1ff2:	61 95       	neg	r22
    1ff4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ff8:	9f 4f       	sbci	r25, 0xFF	; 255
    1ffa:	08 95       	ret

00001ffc <__floatunsisf>:
    1ffc:	e8 94       	clt
    1ffe:	09 c0       	rjmp	.+18     	; 0x2012 <__floatsisf+0x12>

00002000 <__floatsisf>:
    2000:	97 fb       	bst	r25, 7
    2002:	3e f4       	brtc	.+14     	; 0x2012 <__floatsisf+0x12>
    2004:	90 95       	com	r25
    2006:	80 95       	com	r24
    2008:	70 95       	com	r23
    200a:	61 95       	neg	r22
    200c:	7f 4f       	sbci	r23, 0xFF	; 255
    200e:	8f 4f       	sbci	r24, 0xFF	; 255
    2010:	9f 4f       	sbci	r25, 0xFF	; 255
    2012:	99 23       	and	r25, r25
    2014:	a9 f0       	breq	.+42     	; 0x2040 <__floatsisf+0x40>
    2016:	f9 2f       	mov	r31, r25
    2018:	96 e9       	ldi	r25, 0x96	; 150
    201a:	bb 27       	eor	r27, r27
    201c:	93 95       	inc	r25
    201e:	f6 95       	lsr	r31
    2020:	87 95       	ror	r24
    2022:	77 95       	ror	r23
    2024:	67 95       	ror	r22
    2026:	b7 95       	ror	r27
    2028:	f1 11       	cpse	r31, r1
    202a:	f8 cf       	rjmp	.-16     	; 0x201c <__floatsisf+0x1c>
    202c:	fa f4       	brpl	.+62     	; 0x206c <__floatsisf+0x6c>
    202e:	bb 0f       	add	r27, r27
    2030:	11 f4       	brne	.+4      	; 0x2036 <__floatsisf+0x36>
    2032:	60 ff       	sbrs	r22, 0
    2034:	1b c0       	rjmp	.+54     	; 0x206c <__floatsisf+0x6c>
    2036:	6f 5f       	subi	r22, 0xFF	; 255
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	8f 4f       	sbci	r24, 0xFF	; 255
    203c:	9f 4f       	sbci	r25, 0xFF	; 255
    203e:	16 c0       	rjmp	.+44     	; 0x206c <__floatsisf+0x6c>
    2040:	88 23       	and	r24, r24
    2042:	11 f0       	breq	.+4      	; 0x2048 <__floatsisf+0x48>
    2044:	96 e9       	ldi	r25, 0x96	; 150
    2046:	11 c0       	rjmp	.+34     	; 0x206a <__floatsisf+0x6a>
    2048:	77 23       	and	r23, r23
    204a:	21 f0       	breq	.+8      	; 0x2054 <__floatsisf+0x54>
    204c:	9e e8       	ldi	r25, 0x8E	; 142
    204e:	87 2f       	mov	r24, r23
    2050:	76 2f       	mov	r23, r22
    2052:	05 c0       	rjmp	.+10     	; 0x205e <__floatsisf+0x5e>
    2054:	66 23       	and	r22, r22
    2056:	71 f0       	breq	.+28     	; 0x2074 <__floatsisf+0x74>
    2058:	96 e8       	ldi	r25, 0x86	; 134
    205a:	86 2f       	mov	r24, r22
    205c:	70 e0       	ldi	r23, 0x00	; 0
    205e:	60 e0       	ldi	r22, 0x00	; 0
    2060:	2a f0       	brmi	.+10     	; 0x206c <__floatsisf+0x6c>
    2062:	9a 95       	dec	r25
    2064:	66 0f       	add	r22, r22
    2066:	77 1f       	adc	r23, r23
    2068:	88 1f       	adc	r24, r24
    206a:	da f7       	brpl	.-10     	; 0x2062 <__floatsisf+0x62>
    206c:	88 0f       	add	r24, r24
    206e:	96 95       	lsr	r25
    2070:	87 95       	ror	r24
    2072:	97 f9       	bld	r25, 7
    2074:	08 95       	ret

00002076 <__fp_cmp>:
    2076:	99 0f       	add	r25, r25
    2078:	00 08       	sbc	r0, r0
    207a:	55 0f       	add	r21, r21
    207c:	aa 0b       	sbc	r26, r26
    207e:	e0 e8       	ldi	r30, 0x80	; 128
    2080:	fe ef       	ldi	r31, 0xFE	; 254
    2082:	16 16       	cp	r1, r22
    2084:	17 06       	cpc	r1, r23
    2086:	e8 07       	cpc	r30, r24
    2088:	f9 07       	cpc	r31, r25
    208a:	c0 f0       	brcs	.+48     	; 0x20bc <__fp_cmp+0x46>
    208c:	12 16       	cp	r1, r18
    208e:	13 06       	cpc	r1, r19
    2090:	e4 07       	cpc	r30, r20
    2092:	f5 07       	cpc	r31, r21
    2094:	98 f0       	brcs	.+38     	; 0x20bc <__fp_cmp+0x46>
    2096:	62 1b       	sub	r22, r18
    2098:	73 0b       	sbc	r23, r19
    209a:	84 0b       	sbc	r24, r20
    209c:	95 0b       	sbc	r25, r21
    209e:	39 f4       	brne	.+14     	; 0x20ae <__fp_cmp+0x38>
    20a0:	0a 26       	eor	r0, r26
    20a2:	61 f0       	breq	.+24     	; 0x20bc <__fp_cmp+0x46>
    20a4:	23 2b       	or	r18, r19
    20a6:	24 2b       	or	r18, r20
    20a8:	25 2b       	or	r18, r21
    20aa:	21 f4       	brne	.+8      	; 0x20b4 <__fp_cmp+0x3e>
    20ac:	08 95       	ret
    20ae:	0a 26       	eor	r0, r26
    20b0:	09 f4       	brne	.+2      	; 0x20b4 <__fp_cmp+0x3e>
    20b2:	a1 40       	sbci	r26, 0x01	; 1
    20b4:	a6 95       	lsr	r26
    20b6:	8f ef       	ldi	r24, 0xFF	; 255
    20b8:	81 1d       	adc	r24, r1
    20ba:	81 1d       	adc	r24, r1
    20bc:	08 95       	ret

000020be <__fp_split3>:
    20be:	57 fd       	sbrc	r21, 7
    20c0:	90 58       	subi	r25, 0x80	; 128
    20c2:	44 0f       	add	r20, r20
    20c4:	55 1f       	adc	r21, r21
    20c6:	59 f0       	breq	.+22     	; 0x20de <__fp_splitA+0x10>
    20c8:	5f 3f       	cpi	r21, 0xFF	; 255
    20ca:	71 f0       	breq	.+28     	; 0x20e8 <__fp_splitA+0x1a>
    20cc:	47 95       	ror	r20

000020ce <__fp_splitA>:
    20ce:	88 0f       	add	r24, r24
    20d0:	97 fb       	bst	r25, 7
    20d2:	99 1f       	adc	r25, r25
    20d4:	61 f0       	breq	.+24     	; 0x20ee <__fp_splitA+0x20>
    20d6:	9f 3f       	cpi	r25, 0xFF	; 255
    20d8:	79 f0       	breq	.+30     	; 0x20f8 <__fp_splitA+0x2a>
    20da:	87 95       	ror	r24
    20dc:	08 95       	ret
    20de:	12 16       	cp	r1, r18
    20e0:	13 06       	cpc	r1, r19
    20e2:	14 06       	cpc	r1, r20
    20e4:	55 1f       	adc	r21, r21
    20e6:	f2 cf       	rjmp	.-28     	; 0x20cc <__fp_split3+0xe>
    20e8:	46 95       	lsr	r20
    20ea:	f1 df       	rcall	.-30     	; 0x20ce <__fp_splitA>
    20ec:	08 c0       	rjmp	.+16     	; 0x20fe <__fp_splitA+0x30>
    20ee:	16 16       	cp	r1, r22
    20f0:	17 06       	cpc	r1, r23
    20f2:	18 06       	cpc	r1, r24
    20f4:	99 1f       	adc	r25, r25
    20f6:	f1 cf       	rjmp	.-30     	; 0x20da <__fp_splitA+0xc>
    20f8:	86 95       	lsr	r24
    20fa:	71 05       	cpc	r23, r1
    20fc:	61 05       	cpc	r22, r1
    20fe:	08 94       	sec
    2100:	08 95       	ret

00002102 <__fp_zero>:
    2102:	e8 94       	clt

00002104 <__fp_szero>:
    2104:	bb 27       	eor	r27, r27
    2106:	66 27       	eor	r22, r22
    2108:	77 27       	eor	r23, r23
    210a:	cb 01       	movw	r24, r22
    210c:	97 f9       	bld	r25, 7
    210e:	08 95       	ret

00002110 <__gesf2>:
    2110:	0e 94 3b 10 	call	0x2076	; 0x2076 <__fp_cmp>
    2114:	08 f4       	brcc	.+2      	; 0x2118 <__gesf2+0x8>
    2116:	8f ef       	ldi	r24, 0xFF	; 255
    2118:	08 95       	ret

0000211a <__mulsf3>:
    211a:	0e 94 a0 10 	call	0x2140	; 0x2140 <__mulsf3x>
    211e:	0c 94 11 11 	jmp	0x2222	; 0x2222 <__fp_round>
    2122:	0e 94 03 11 	call	0x2206	; 0x2206 <__fp_pscA>
    2126:	38 f0       	brcs	.+14     	; 0x2136 <__mulsf3+0x1c>
    2128:	0e 94 0a 11 	call	0x2214	; 0x2214 <__fp_pscB>
    212c:	20 f0       	brcs	.+8      	; 0x2136 <__mulsf3+0x1c>
    212e:	95 23       	and	r25, r21
    2130:	11 f0       	breq	.+4      	; 0x2136 <__mulsf3+0x1c>
    2132:	0c 94 fa 10 	jmp	0x21f4	; 0x21f4 <__fp_inf>
    2136:	0c 94 00 11 	jmp	0x2200	; 0x2200 <__fp_nan>
    213a:	11 24       	eor	r1, r1
    213c:	0c 94 82 10 	jmp	0x2104	; 0x2104 <__fp_szero>

00002140 <__mulsf3x>:
    2140:	0e 94 5f 10 	call	0x20be	; 0x20be <__fp_split3>
    2144:	70 f3       	brcs	.-36     	; 0x2122 <__mulsf3+0x8>

00002146 <__mulsf3_pse>:
    2146:	95 9f       	mul	r25, r21
    2148:	c1 f3       	breq	.-16     	; 0x213a <__mulsf3+0x20>
    214a:	95 0f       	add	r25, r21
    214c:	50 e0       	ldi	r21, 0x00	; 0
    214e:	55 1f       	adc	r21, r21
    2150:	62 9f       	mul	r22, r18
    2152:	f0 01       	movw	r30, r0
    2154:	72 9f       	mul	r23, r18
    2156:	bb 27       	eor	r27, r27
    2158:	f0 0d       	add	r31, r0
    215a:	b1 1d       	adc	r27, r1
    215c:	63 9f       	mul	r22, r19
    215e:	aa 27       	eor	r26, r26
    2160:	f0 0d       	add	r31, r0
    2162:	b1 1d       	adc	r27, r1
    2164:	aa 1f       	adc	r26, r26
    2166:	64 9f       	mul	r22, r20
    2168:	66 27       	eor	r22, r22
    216a:	b0 0d       	add	r27, r0
    216c:	a1 1d       	adc	r26, r1
    216e:	66 1f       	adc	r22, r22
    2170:	82 9f       	mul	r24, r18
    2172:	22 27       	eor	r18, r18
    2174:	b0 0d       	add	r27, r0
    2176:	a1 1d       	adc	r26, r1
    2178:	62 1f       	adc	r22, r18
    217a:	73 9f       	mul	r23, r19
    217c:	b0 0d       	add	r27, r0
    217e:	a1 1d       	adc	r26, r1
    2180:	62 1f       	adc	r22, r18
    2182:	83 9f       	mul	r24, r19
    2184:	a0 0d       	add	r26, r0
    2186:	61 1d       	adc	r22, r1
    2188:	22 1f       	adc	r18, r18
    218a:	74 9f       	mul	r23, r20
    218c:	33 27       	eor	r19, r19
    218e:	a0 0d       	add	r26, r0
    2190:	61 1d       	adc	r22, r1
    2192:	23 1f       	adc	r18, r19
    2194:	84 9f       	mul	r24, r20
    2196:	60 0d       	add	r22, r0
    2198:	21 1d       	adc	r18, r1
    219a:	82 2f       	mov	r24, r18
    219c:	76 2f       	mov	r23, r22
    219e:	6a 2f       	mov	r22, r26
    21a0:	11 24       	eor	r1, r1
    21a2:	9f 57       	subi	r25, 0x7F	; 127
    21a4:	50 40       	sbci	r21, 0x00	; 0
    21a6:	9a f0       	brmi	.+38     	; 0x21ce <__mulsf3_pse+0x88>
    21a8:	f1 f0       	breq	.+60     	; 0x21e6 <__mulsf3_pse+0xa0>
    21aa:	88 23       	and	r24, r24
    21ac:	4a f0       	brmi	.+18     	; 0x21c0 <__mulsf3_pse+0x7a>
    21ae:	ee 0f       	add	r30, r30
    21b0:	ff 1f       	adc	r31, r31
    21b2:	bb 1f       	adc	r27, r27
    21b4:	66 1f       	adc	r22, r22
    21b6:	77 1f       	adc	r23, r23
    21b8:	88 1f       	adc	r24, r24
    21ba:	91 50       	subi	r25, 0x01	; 1
    21bc:	50 40       	sbci	r21, 0x00	; 0
    21be:	a9 f7       	brne	.-22     	; 0x21aa <__mulsf3_pse+0x64>
    21c0:	9e 3f       	cpi	r25, 0xFE	; 254
    21c2:	51 05       	cpc	r21, r1
    21c4:	80 f0       	brcs	.+32     	; 0x21e6 <__mulsf3_pse+0xa0>
    21c6:	0c 94 fa 10 	jmp	0x21f4	; 0x21f4 <__fp_inf>
    21ca:	0c 94 82 10 	jmp	0x2104	; 0x2104 <__fp_szero>
    21ce:	5f 3f       	cpi	r21, 0xFF	; 255
    21d0:	e4 f3       	brlt	.-8      	; 0x21ca <__mulsf3_pse+0x84>
    21d2:	98 3e       	cpi	r25, 0xE8	; 232
    21d4:	d4 f3       	brlt	.-12     	; 0x21ca <__mulsf3_pse+0x84>
    21d6:	86 95       	lsr	r24
    21d8:	77 95       	ror	r23
    21da:	67 95       	ror	r22
    21dc:	b7 95       	ror	r27
    21de:	f7 95       	ror	r31
    21e0:	e7 95       	ror	r30
    21e2:	9f 5f       	subi	r25, 0xFF	; 255
    21e4:	c1 f7       	brne	.-16     	; 0x21d6 <__mulsf3_pse+0x90>
    21e6:	fe 2b       	or	r31, r30
    21e8:	88 0f       	add	r24, r24
    21ea:	91 1d       	adc	r25, r1
    21ec:	96 95       	lsr	r25
    21ee:	87 95       	ror	r24
    21f0:	97 f9       	bld	r25, 7
    21f2:	08 95       	ret

000021f4 <__fp_inf>:
    21f4:	97 f9       	bld	r25, 7
    21f6:	9f 67       	ori	r25, 0x7F	; 127
    21f8:	80 e8       	ldi	r24, 0x80	; 128
    21fa:	70 e0       	ldi	r23, 0x00	; 0
    21fc:	60 e0       	ldi	r22, 0x00	; 0
    21fe:	08 95       	ret

00002200 <__fp_nan>:
    2200:	9f ef       	ldi	r25, 0xFF	; 255
    2202:	80 ec       	ldi	r24, 0xC0	; 192
    2204:	08 95       	ret

00002206 <__fp_pscA>:
    2206:	00 24       	eor	r0, r0
    2208:	0a 94       	dec	r0
    220a:	16 16       	cp	r1, r22
    220c:	17 06       	cpc	r1, r23
    220e:	18 06       	cpc	r1, r24
    2210:	09 06       	cpc	r0, r25
    2212:	08 95       	ret

00002214 <__fp_pscB>:
    2214:	00 24       	eor	r0, r0
    2216:	0a 94       	dec	r0
    2218:	12 16       	cp	r1, r18
    221a:	13 06       	cpc	r1, r19
    221c:	14 06       	cpc	r1, r20
    221e:	05 06       	cpc	r0, r21
    2220:	08 95       	ret

00002222 <__fp_round>:
    2222:	09 2e       	mov	r0, r25
    2224:	03 94       	inc	r0
    2226:	00 0c       	add	r0, r0
    2228:	11 f4       	brne	.+4      	; 0x222e <__fp_round+0xc>
    222a:	88 23       	and	r24, r24
    222c:	52 f0       	brmi	.+20     	; 0x2242 <__fp_round+0x20>
    222e:	bb 0f       	add	r27, r27
    2230:	40 f4       	brcc	.+16     	; 0x2242 <__fp_round+0x20>
    2232:	bf 2b       	or	r27, r31
    2234:	11 f4       	brne	.+4      	; 0x223a <__fp_round+0x18>
    2236:	60 ff       	sbrs	r22, 0
    2238:	04 c0       	rjmp	.+8      	; 0x2242 <__fp_round+0x20>
    223a:	6f 5f       	subi	r22, 0xFF	; 255
    223c:	7f 4f       	sbci	r23, 0xFF	; 255
    223e:	8f 4f       	sbci	r24, 0xFF	; 255
    2240:	9f 4f       	sbci	r25, 0xFF	; 255
    2242:	08 95       	ret

00002244 <__udivmodsi4>:
    2244:	a1 e2       	ldi	r26, 0x21	; 33
    2246:	1a 2e       	mov	r1, r26
    2248:	aa 1b       	sub	r26, r26
    224a:	bb 1b       	sub	r27, r27
    224c:	fd 01       	movw	r30, r26
    224e:	0d c0       	rjmp	.+26     	; 0x226a <__udivmodsi4_ep>

00002250 <__udivmodsi4_loop>:
    2250:	aa 1f       	adc	r26, r26
    2252:	bb 1f       	adc	r27, r27
    2254:	ee 1f       	adc	r30, r30
    2256:	ff 1f       	adc	r31, r31
    2258:	a2 17       	cp	r26, r18
    225a:	b3 07       	cpc	r27, r19
    225c:	e4 07       	cpc	r30, r20
    225e:	f5 07       	cpc	r31, r21
    2260:	20 f0       	brcs	.+8      	; 0x226a <__udivmodsi4_ep>
    2262:	a2 1b       	sub	r26, r18
    2264:	b3 0b       	sbc	r27, r19
    2266:	e4 0b       	sbc	r30, r20
    2268:	f5 0b       	sbc	r31, r21

0000226a <__udivmodsi4_ep>:
    226a:	66 1f       	adc	r22, r22
    226c:	77 1f       	adc	r23, r23
    226e:	88 1f       	adc	r24, r24
    2270:	99 1f       	adc	r25, r25
    2272:	1a 94       	dec	r1
    2274:	69 f7       	brne	.-38     	; 0x2250 <__udivmodsi4_loop>
    2276:	60 95       	com	r22
    2278:	70 95       	com	r23
    227a:	80 95       	com	r24
    227c:	90 95       	com	r25
    227e:	9b 01       	movw	r18, r22
    2280:	ac 01       	movw	r20, r24
    2282:	bd 01       	movw	r22, r26
    2284:	cf 01       	movw	r24, r30
    2286:	08 95       	ret

00002288 <memcpy>:
    2288:	fb 01       	movw	r30, r22
    228a:	dc 01       	movw	r26, r24
    228c:	02 c0       	rjmp	.+4      	; 0x2292 <memcpy+0xa>
    228e:	01 90       	ld	r0, Z+
    2290:	0d 92       	st	X+, r0
    2292:	41 50       	subi	r20, 0x01	; 1
    2294:	50 40       	sbci	r21, 0x00	; 0
    2296:	d8 f7       	brcc	.-10     	; 0x228e <memcpy+0x6>
    2298:	08 95       	ret

0000229a <_exit>:
    229a:	f8 94       	cli

0000229c <__stop_program>:
    229c:	ff cf       	rjmp	.-2      	; 0x229c <__stop_program>
